Doxyfile:# Filters (see: http://doc.qt.io/qt-4.8/qthelpproject.html#custom-filters).
Doxyfile:# Filters (see: http://doc.qt.io/qt-4.8/qthelpproject.html#custom-filters).
Makefile:  CPP := $(DEVKITARM)/bin/arm-none-eabi-cpp -P
Makefile:  OBJDUMP := $(DEVKITARM)/bin/arm-none-eabi-objdump
Makefile:  OBJCOPY := $(DEVKITARM)/bin/arm-none-eabi-objcopy
Makefile:  AS := $(DEVKITARM)/bin/arm-none-eabi-as
Makefile:  CC := $(DEVKITARM)/bin/arm-none-eabi-gcc
Makefile:  CXX := $(DEVKITARM)/bin/arm-none-eabi-g++
Makefile:  # For the asm-processor, since it doesn't support -O3. Probably not actually compiled with these flags.
README.md:RM2C is the tool I developed to be able to port romhacks: [RM2C](https://gitlab.com/scuttlebugraiser/rom-manger-2-c)
enhancements/60fps.patch:+    if ((m->action == ACT_SLEEPING) || (m->action == ACT_START_SLEEPING)) {
enhancements/60fps.patch:+    if (m->area->camera->cutscene == CUTSCENE_0F_UNUSED) {
enhancements/60fps.patch:+    if (m->area->camera->mode == CAMERA_MODE_FIXED && m->area->camera->cutscene == 0) {
enhancements/60fps.patch:+    if (m->area->camera->mode == CAMERA_MODE_FIXED && m->area->camera->cutscene == 0) {
enhancements/60fps.patch:     gCurAnimEnabled = (anim->flags & ANIM_FLAG_5) == 0;
enhancements/60fps.patch:     gCurrAnimAttribute = segmented_to_virtual((void *) anim->index);
enhancements/60fps.patch:     gCurAnimData = segmented_to_virtual((void *) anim->values);
enhancements/ext_bounds_col_patches.patch:         m->floorHeight = find_floor(m->pos[0], m->pos[1], m->pos[2], &m->floor);
enhancements/ext_bounds_col_patches.patch:-    m->ceilHeight = vec3f_find_ceil(&m->pos[0], m->floorHeight, &m->ceil);
enhancements/ext_bounds_col_patches.patch:+    m->ceilHeight = vec3f_find_ceil(&m->pos[0], m->pos[1], &m->ceil);
enhancements/ext_bounds_col_patches.patch:     gasLevel = find_poison_gas_level(m->pos[0], m->pos[2]);
enhancements/ext_bounds_col_patches.patch:     m->waterLevel = find_water_level(m->pos[0], m->pos[2]);
enhancements/ext_bounds_col_patches.patch:+    magnitude = sqrtf((m->controller->stickX*m->controller->stickX + m->controller->stickY*m->controller->stickY)); 
enhancements/ext_bounds_col_patches.patch:+    x = magnitude * sins(m->intendedYaw); 
enhancements/ext_bounds_col_patches.patch:+    z = magnitude * coss(m->intendedYaw);
enhancements/ext_bounds_col_patches.patch:+    m->pos[0]+=m->platformDisplacement[0];
enhancements/ext_bounds_col_patches.patch:+    m->vel[1]+=m->platformDisplacement[1];
enhancements/ext_bounds_col_patches.patch:+    m->platformDisplacement[1] = 0;
enhancements/ext_bounds_col_patches.patch:+    m->pos[2]+=m->platformDisplacement[2];
enhancements/ext_bounds_col_patches.patch:+    if (absf2(m->platformDisplacement[0]+ x) < absf2(m->platformDisplacement[0])){
enhancements/ext_bounds_col_patches.patch:+        m->platformDisplacement[0]+=x;
enhancements/ext_bounds_col_patches.patch:+    if (absf2(m->platformDisplacement[2]+ z) < absf2(m->platformDisplacement[2])){
enhancements/ext_bounds_col_patches.patch:+        m->platformDisplacement[2]+=z;
enhancements/ext_bounds_col_patches.patch:     m->wall = resolve_and_return_wall_collisions(nextPos, 50.0f, 50.0f);
enhancements/ext_bounds_col_patches.patch:-        intendedPos[0] = m->pos[0] + m->floor->normal.y * (m->vel[0] / 4.0f);
enhancements/ext_bounds_col_patches.patch:-        intendedPos[2] = m->pos[2] + m->floor->normal.y * (m->vel[2] / 4.0f);
enhancements/ext_bounds_col_patches.patch:+        s16 moveDir = atan2s(m->vel[2], m->vel[0]);
enhancements/ext_bounds_col_patches.patch:+        float speedFactor = m->floor->normal.y / sqrtf(sqr(m->floor->normal.y) + sqr(m->floor->normal.x * moveX + m->floor->normal.z * moveZ));
enhancements/ext_bounds_col_patches.patch:+        intendedPos[0] = m->pos[0] + speedFactor * (m->vel[0] / 4.0f);
enhancements/ext_bounds_col_patches.patch:+        intendedPos[2] = m->pos[2] + speedFactor * (m->vel[2] / 4.0f);
enhancements/ext_bounds_col_patches.patch:         intendedPos[1] = m->pos[1];
enhancements/record_demo.patch:+// Prints the status on the bottom-left side of the screen in colorful text.
include/macros.h:// asm-process isn't supported outside of IDO, and undefined behavior causes
include/seq_macros.inc:# To regenerate it, run: ./tools/seq_decoder.py --emit-asm-macros >seq_macros.inc
include/stb/stb_image.h:// zlib-from-memory implementation for PNG reading
include/stb/stb_image.h:      // force the image data from big-endian to platform-native.
include/tinfl.h:  pStream->data_type = 0;
include/tinfl.h:  pStream->adler = 0;
include/tinfl.h:  pStream->msg = NULL;
include/tinfl.h:  pStream->total_in = 0;
include/tinfl.h:  pStream->total_out = 0;
include/tinfl.h:  pStream->reserved = 0;
include/tinfl.h:  if (!pStream->zalloc) pStream->zalloc = tinfl_def_alloc_func;
include/tinfl.h:  if (!pStream->zfree) pStream->zfree = tinfl_def_free_func;
include/tinfl.h:  pDecomp = (inflate_state*)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));
include/tinfl.h:  pStream->state = (struct mz_internal_state *)pDecomp;
include/tinfl.h:  if ((!pStream) || (!pStream->state)) return MZ_STREAM_ERROR;
include/tinfl.h:  pState = (inflate_state*)pStream->state;
include/tinfl.h:  orig_avail_in = pStream->avail_in;
include/tinfl.h:    in_bytes = pStream->avail_in; out_bytes = pStream->avail_out;
include/tinfl.h:    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);
include/tinfl.h:    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes; pStream->total_in += (mz_uint)in_bytes;
include/tinfl.h:    pStream->adler = tinfl_get_adler32(&pState->m_decomp);
include/tinfl.h:    pStream->next_out += (mz_uint)out_bytes; pStream->avail_out -= (mz_uint)out_bytes; pStream->total_out += (mz_uint)out_bytes;
include/tinfl.h:    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
include/tinfl.h:    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
include/tinfl.h:    pStream->next_out += n; pStream->avail_out -= n; pStream->total_out += n;
include/tinfl.h:    in_bytes = pStream->avail_in;
include/tinfl.h:    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
include/tinfl.h:    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes;
include/tinfl.h:    pStream->total_in += (mz_uint)in_bytes; pStream->adler = tinfl_get_adler32(&pState->m_decomp);
include/tinfl.h:    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
include/tinfl.h:    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
include/tinfl.h:    pStream->next_out += n; pStream->avail_out -= n; pStream->total_out += n;
include/tinfl.h:       else if (!pStream->avail_out)
include/tinfl.h:    else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))
include/tinfl.h:  if (pStream->state)
include/tinfl.h:    pStream->zfree(pStream->opaque, pStream->state);
include/tinfl.h:    pStream->state = NULL;
Binary file levels/menu/main_menu_seg7.02018.rgba16.png matches
lib/src/guMtxF2L.c:    s32 *m1 = &m->m[0][0];
lib/src/guMtxF2L.c:    s32 *m2 = &m->m[2][0];
lib/src/guMtxF2L.c:    m1 = (u32 *) &m->m[0][0];
lib/src/guMtxF2L.c:    m2 = (u32 *) &m->m[2][0];
lib/src/guMtxF2L.c:    guMtxIdentF(m->m);
pisetup.sh:sudo apt install -y libdrm-dev libgbm-dev
sound/README.md:custom-made samples and sequences it is advisable to include that substring
src/audio/copt/seq_channel_layer_process_script_copt.inc.c:                    layer->adsr.envelope = drum->envelope;
src/audio/copt/seq_channel_layer_process_script_copt.inc.c:                    layer->adsr.releaseRate = drum->releaseRate;
src/audio/copt/seq_channel_layer_process_script_copt.inc.c:                    layer->pan = FLOAT_CAST(drum->pan) / US_FLOAT(128.0);
src/audio/copt/seq_channel_layer_process_script_copt.inc.c:                    layer->sound = &drum->sound;
src/audio/heap.c:                            func_sh_802F2320(entry, drum->sound.sample);
src/audio/heap.c:                                func_sh_802F2320(entry, drum->sound.sample);
src/audio/load.c:        func_sh_802f2f38(drum->sound.sample, bankId);
src/audio/load.c:    itInstrs = mem->drums;
src/audio/load.c:    if (mem->drums) {
src/audio/load.c:    drums = mem->drums;
src/audio/load.c:        mem->drums = (void *)((uintptr_t) drums + (uintptr_t) mem);
src/audio/load.c:        mem->drums = PATCH(drums, mem);
src/audio/load.c:            mem->drums = PATCH(itInstrs, mem);
src/audio/load.c:            patched = mem->drums[i];
src/audio/load.c:                mem->drums[i] = drum;
src/audio/load.c:                if (drum->loaded == 0) {
src/audio/load.c:                    drum->envelope = BASE_OFFSET(mem, patched);
src/audio/load.c:                    patch_sound(&drum->sound, (u8 *) mem, offset);
src/audio/load.c:                    func_sh_802f51d4(&drum->sound, mem, patchInfo);
src/audio/load.c:                    patched = drum->envelope;
src/audio/load.c:                    drum->envelope = BASE_OFFSET(patched, mem);
src/audio/load.c:                    drum->loaded = 1;
src/audio/load.c:        itInstrs = mem->instruments;
src/audio/load.c:    gCtlEntries[bankId].drums = mem->drums;
src/audio/load.c:    gCtlEntries[bankId].instruments = mem->instruments;
src/audio/load.c:    m->hdr.pri = pri;
src/audio/load.c:    m->hdr.retQueue = retQueue;
src/audio/load.c:    m->dramAddr = dramAddr;
src/audio/load.c:    m->devAddr = devAddr;
src/audio/load.c:    m->size = size;
src/audio/load.c:        ret = drum->sound.sample;
src/audio/load.c:    item->inProgress = 1;
src/audio/load.c:    item->devAddr = devAddr;
src/audio/load.c:    item->audioBank = vAddr;
src/audio/load.c:    item->vAddr = vAddr;
src/audio/load.c:    item->remaining = size;
src/audio/load.c:        item->transferSize = 0x1000;
src/audio/load.c:        item->transferSize = ((size / numChunks) + 0xFF) & ~0xFF;
src/audio/load.c:        if (item->transferSize < 0x100) {
src/audio/load.c:            item->transferSize = 0x100;
src/audio/load.c:    item->retQueue = retQueue;
src/audio/load.c:    item->timer = 3;
src/audio/load.c:    item->medium = medium;
src/audio/load.c:    item->encodedInfo = encodedInfo;
src/audio/load.c:    osCreateMesgQueue(&item->dmaRetQueue, item->mesgs, 1);
src/audio/load.c:        numLoaded = func_sh_802f5900(drum->sound.sample, numLoaded, list);
src/audio/playback.c:    if (item->prev != NULL) {
src/audio/playback.c:        item->prev = list;
src/audio/playback.c:        item->next = list->next;
src/audio/playback.c:        item->pool = list->pool;
src/audio/playback.c:    if (item->prev == NULL) {
src/audio/playback.c:        item->prev->next = item->next;
src/audio/playback.c:        item->next->prev = item->prev;
src/audio/playback.c:        item->prev = NULL;
src/audio/seqplayer.c:        if (item->prev == NULL) {
src/audio/seqplayer.c:            item->prev = gLayerFreeList.prev;
src/audio/seqplayer.c:            item->next = &gLayerFreeList;
src/audio/seqplayer.c:            item->pool = gLayerFreeList.pool;
src/audio/seqplayer.c:    if (item->prev != NULL) {
src/audio/seqplayer.c:        item->prev = list->prev;
src/audio/seqplayer.c:        item->next = list;
src/audio/seqplayer.c:        item->pool = list->pool;
src/audio/seqplayer.c:    item->prev->next = list;
src/audio/seqplayer.c:    list->prev = item->prev;
src/audio/seqplayer.c:    item->prev = NULL;
src/audio/seqplayer.c:    return item->u.value;
src/audio/seqplayer.c:                    layer->adsr.envelope = drum->envelope;
src/audio/seqplayer.c:                    layer->adsr.releaseRate = drum->releaseRate;
src/audio/seqplayer.c:                        layer->pan = drum->pan;
src/audio/seqplayer.c:                    layer->pan = FLOAT_CAST(drum->pan) / US_FLOAT(128.0);
src/audio/seqplayer.c:                    layer->sound = &drum->sound;
src/audio/seqplayer.c:            layer->adsr.envelope = drum->envelope;
src/audio/seqplayer.c:            layer->adsr.releaseRate = drum->releaseRate;
src/audio/seqplayer.c:                layer->pan = drum->pan;
src/audio/seqplayer.c:            layer->sound = &drum->sound;
src/audio/synthesis.c:            osInvalDCache(item->toDownsampleLeft, DEFAULT_LEN_2CH);
src/audio/synthesis.c:            for (srcPos = 0, dstPos = 0; dstPos < item->lengthA / 2;
src/audio/synthesis.c:                reverb->ringBuffer.left[item->startPos + dstPos] =
src/audio/synthesis.c:                    item->toDownsampleLeft[srcPos];
src/audio/synthesis.c:                reverb->ringBuffer.right[item->startPos + dstPos] =
src/audio/synthesis.c:                    item->toDownsampleRight[srcPos];
src/audio/synthesis.c:            for (dstPos = 0; dstPos < item->lengthB / 2; srcPos += reverb->downsampleRate, dstPos++) {
src/audio/synthesis.c:                reverb->ringBuffer.left[dstPos] = item->toDownsampleLeft[srcPos];
src/audio/synthesis.c:                reverb->ringBuffer.right[dstPos] = item->toDownsampleRight[srcPos];
src/audio/synthesis.c:        item->lengthA = nSamples * 2;
src/audio/synthesis.c:        item->lengthB = 0;
src/audio/synthesis.c:        item->startPos = (s32) reverb->nextRingBufferPos;
src/audio/synthesis.c:        item->lengthA = (nSamples - excessiveSamples) * 2;
src/audio/synthesis.c:        item->lengthB = excessiveSamples * 2;
src/audio/synthesis.c:        item->startPos = reverb->nextRingBufferPos;
src/audio/synthesis.c:    item->numSamplesAfterDownsampling = nSamples;
src/audio/synthesis.c:    item->chunkLen = chunkLen;
src/audio/synthesis.c:            osInvalDCache(item->toDownsampleLeft, DEFAULT_LEN_2CH);
src/audio/synthesis.c:            for (srcPos = 0, dstPos = 0; dstPos < item->lengthA / 2;
src/audio/synthesis.c:                gSynthesisReverb.ringBuffer.left[dstPos + item->startPos] =
src/audio/synthesis.c:                    item->toDownsampleLeft[srcPos];
src/audio/synthesis.c:                gSynthesisReverb.ringBuffer.right[dstPos + item->startPos] =
src/audio/synthesis.c:                    item->toDownsampleRight[srcPos];
src/audio/synthesis.c:            for (dstPos = 0; dstPos < item->lengthB / 2; srcPos += gReverbDownsampleRate, dstPos++) {
src/audio/synthesis.c:                gSynthesisReverb.ringBuffer.left[dstPos] = item->toDownsampleLeft[srcPos];
src/audio/synthesis.c:                gSynthesisReverb.ringBuffer.right[dstPos] = item->toDownsampleRight[srcPos];
src/audio/synthesis.c:        item->lengthA = numSamplesAfterDownsampling * 2;
src/audio/synthesis.c:        item->lengthB = 0;
src/audio/synthesis.c:        item->startPos = (s32) gSynthesisReverb.nextRingBufferPos;
src/audio/synthesis.c:        item->lengthA = nSamples * 2;
src/audio/synthesis.c:        item->lengthB = excessiveSamples * 2;
src/audio/synthesis.c:        item->startPos = gSynthesisReverb.nextRingBufferPos;
src/audio/synthesis.c:    item->numSamplesAfterDownsampling = numSamplesAfterDownsampling;
src/audio/synthesis.c:    item->chunkLen = chunkLen;
src/audio/synthesis.c:        cmd = synthesis_load_reverb_ring_buffer(cmd, DMEM_ADDR_WET_LEFT_CH, item->startPos, item->lengthA, reverbIndex);
src/audio/synthesis.c:        if (item->lengthB != 0) {
src/audio/synthesis.c:            cmd = synthesis_load_reverb_ring_buffer(cmd, DMEM_ADDR_WET_LEFT_CH + item->lengthA, 0, item->lengthB, reverbIndex);
src/audio/synthesis.c:        startPad = (item->startPos % 8u) * 2;
src/audio/synthesis.c:        paddedLengthA = ALIGN(startPad + item->lengthA, 4);
src/audio/synthesis.c:        cmd = synthesis_load_reverb_ring_buffer(cmd, DMEM_ADDR_RESAMPLED, (item->startPos - startPad / 2), DEFAULT_LEN_1CH, reverbIndex);
src/audio/synthesis.c:        if (item->lengthB != 0) {
src/audio/synthesis.c:    cmd = synthesis_load_reverb_ring_buffer(cmd, DMEM_ADDR_RESAMPLED, item->startPos, item->lengthA, reverbIndex);
src/audio/synthesis.c:    if (item->lengthB != 0) {
src/audio/synthesis.c:        cmd = synthesis_load_reverb_ring_buffer(cmd, DMEM_ADDR_RESAMPLED + item->lengthA, 0, item->lengthB, reverbIndex);
src/audio/synthesis.c:                cmd = synthesis_save_reverb_ring_buffer(cmd, DMEM_ADDR_WET_LEFT_CH, item->startPos, item->lengthA, reverbIndex);
src/audio/synthesis.c:                if (item->lengthB != 0) {
src/audio/synthesis.c:                    cmd = synthesis_save_reverb_ring_buffer(cmd, DMEM_ADDR_WET_LEFT_CH + item->lengthA, 0, item->lengthB, reverbIndex);
src/audio/synthesis.c:            cmd = synthesis_save_reverb_ring_buffer(cmd, DMEM_ADDR_WET_LEFT_CH, item->startPos, item->lengthA, reverbIndex);
src/audio/synthesis.c:            if (item->lengthB != 0) {
src/audio/synthesis.c:                cmd = synthesis_save_reverb_ring_buffer(cmd, DMEM_ADDR_WET_LEFT_CH + item->lengthA, 0, item->lengthB, reverbIndex);
src/audio/synthesis.c:    cmd = synthesis_save_reverb_ring_buffer(cmd, DMEM_ADDR_RESAMPLED, item->startPos, item->lengthA, reverbIndex);
src/audio/synthesis.c:    if (item->lengthB != 0) {
src/audio/synthesis.c:        cmd = synthesis_save_reverb_ring_buffer(cmd, DMEM_ADDR_RESAMPLED + item->lengthA, 0, item->lengthB, reverbIndex);
src/engine/graph_node.c:        graphNode->animInfo.animFrame = anim->startFrame + ((anim->flags & ANIM_FLAG_FORWARD) ? 1 : -1);
src/engine/graph_node.c:            (anim->startFrame << 16) + ((anim->flags & ANIM_FLAG_FORWARD) ? animAccel : -animAccel);
src/engine/graph_node.c:    if (obj->animTimer == gAreaUpdateCounter || anim->flags & ANIM_FLAG_2) {
src/engine/graph_node.c:    if (anim->flags & ANIM_FLAG_FORWARD) {
src/engine/graph_node.c:        if (GET_HIGH_S16_OF_32(result) < anim->loopStart) {
src/engine/graph_node.c:            if (anim->flags & ANIM_FLAG_NOLOOP) {
src/engine/graph_node.c:                SET_HIGH_S16_OF_32(result, anim->loopStart);
src/engine/graph_node.c:                SET_HIGH_S16_OF_32(result, anim->loopEnd - 1);
src/engine/graph_node.c:        if (GET_HIGH_S16_OF_32(result) >= anim->loopEnd) {
src/engine/graph_node.c:            if (anim->flags & ANIM_FLAG_NOLOOP) {
src/engine/graph_node.c:                SET_HIGH_S16_OF_32(result, anim->loopEnd - 1);
src/engine/graph_node.c:                SET_HIGH_S16_OF_32(result, anim->loopStart);
src/game/behaviors/bowser.inc.c:        if (bowser->header.gfx.animInfo.curAnim->loopEnd == sp30)
src/game/behaviors/bowser.inc.c:    platform->oAngleVelPitch = coss(angle) * a1;
src/game/behaviors/bowser.inc.c:    platform->oAngleVelRoll = -sins(angle) * a1;
src/game/behaviors/bowser.inc.c:                    play_sound(SOUND_ENV_UNKNOWN4, platform->header.gfx.cameraToObject);
src/game/behaviors/bowser.inc.c:            platform->oAngleVelPitch = 0;
src/game/behaviors/bowser.inc.c:            platform->oAngleVelRoll = 0;
src/game/behaviors/bowser.inc.c:            platform->oFaceAnglePitch = 0;
src/game/behaviors/bowser.inc.c:            platform->oFaceAngleRoll = 0;
src/game/behaviors/ferris_wheel.inc.c:            platform->collisionData =
src/game/behaviors/piranha_bubbles.inc.c:    s32 lastFrame = parent->header.gfx.animInfo.curAnim->loopEnd - 2;
src/game/behaviors/tower_platform.inc.c:    platform->oMoveAngleYaw = yaw;
src/game/behaviors/tower_platform.inc.c:    platform->oPosX += o->oPlatformSpawnerUnk100 * sins(yaw);
src/game/behaviors/tower_platform.inc.c:    platform->oPosY += 100 * o->oPlatformSpawnerUnkF4;
src/game/behaviors/tower_platform.inc.c:    platform->oPosZ += o->oPlatformSpawnerUnk100 * coss(yaw);
src/game/behaviors/tower_platform.inc.c:    platform->oPlatformUnk110 = o->oPlatformSpawnerUnk104;
src/game/behaviors/tower_platform.inc.c:    platform->oPlatformUnk10C = o->oPlatformSpawnerUnk108;
src/game/camera.c:    if ((m->action == ACT_SLEEPING) || (m->action == ACT_START_SLEEPING)) {
src/game/camera.c:    if (m->area->camera->cutscene == CUTSCENE_0F_UNUSED) {
src/game/camera.c:    if (m->area->camera->mode == CAMERA_MODE_FIXED && m->area->camera->cutscene == 0) {
src/game/camera.c:    if (m->area->camera->mode == CAMERA_MODE_FIXED && m->area->camera->cutscene == 0) {
src/game/debug.c:s16 gDebugPrintState2[6]; // prints bottom-up?
src/game/ingame_menu.c:                gDialogLineNum--;
src/game/interaction.c:    f32 dx = m->pos[0] - o->oPosX;
src/game/interaction.c:    f32 dz = m->pos[2] - o->oPosZ;
src/game/interaction.c:    f32 dx = o->oPosX - m->pos[0];
src/game/interaction.c:    f32 dz = o->oPosZ - m->pos[2];
src/game/interaction.c:    u32 action = m->action;
src/game/interaction.c:            s16 dYawToObject = mario_obj_angle_to_object(m, o) - m->faceAngle[1];
src/game/interaction.c:            if (m->flags & MARIO_PUNCHING) {
src/game/interaction.c:            if (m->flags & MARIO_KICKING) {
src/game/interaction.c:            if (m->flags & MARIO_TRIPPING) {
src/game/interaction.c:            if (m->vel[1] < 0.0f) {
src/game/interaction.c:            if (m->vel[1] < 0.0f && m->actionState == 0) {
src/game/interaction.c:        } else if (m->forwardVel <= -26.0f || 26.0f <= m->forwardVel) {
src/game/interaction.c:        if (m->vel[1] < 0.0f) {
src/game/interaction.c:            if (m->pos[1] > o->oPosY) {
src/game/interaction.c:            if (m->pos[1] < o->oPosY) {
src/game/interaction.c:    if (m->riddenObj != NULL) {
src/game/interaction.c:        m->riddenObj->oInteractStatus = INT_STATUS_STOP_RIDING;
src/game/interaction.c:        m->riddenObj = NULL;
src/game/interaction.c:    if (m->heldObj == NULL) {
src/game/interaction.c:        m->heldObj = m->usedObj;
src/game/interaction.c:        obj_set_held_state(m->heldObj, bhvCarrySomething3);
src/game/interaction.c:    if (m->heldObj != NULL) {
src/game/interaction.c:        if (m->heldObj->behavior == segmented_to_virtual(bhvKoopaShellUnderwater)) {
src/game/interaction.c:        obj_set_held_state(m->heldObj, bhvCarrySomething4);
src/game/interaction.c:        m->heldObj->oPosX = m->marioBodyState->heldObjLastPosition[0];
src/game/interaction.c:        m->heldObj->oPosY = m->pos[1];
src/game/interaction.c:        m->heldObj->oPosZ = m->marioBodyState->heldObjLastPosition[2];
src/game/interaction.c:        m->heldObj->oMoveAngleYaw = m->faceAngle[1];
src/game/interaction.c:        m->heldObj = NULL;
src/game/interaction.c:    if (m->heldObj != NULL) {
src/game/interaction.c:        if (m->heldObj->behavior == segmented_to_virtual(bhvKoopaShellUnderwater)) {
src/game/interaction.c:        obj_set_held_state(m->heldObj, bhvCarrySomething5);
src/game/interaction.c:        m->heldObj->oPosX = m->marioBodyState->heldObjLastPosition[0] + 32.0f * sins(m->faceAngle[1]);
src/game/interaction.c:        m->heldObj->oPosY = m->marioBodyState->heldObjLastPosition[1];
src/game/interaction.c:        m->heldObj->oPosZ = m->marioBodyState->heldObjLastPosition[2] + 32.0f * coss(m->faceAngle[1]);
src/game/interaction.c:        m->heldObj->oMoveAngleYaw = m->faceAngle[1];
src/game/interaction.c:        m->heldObj = NULL;
src/game/interaction.c:    if (m->action == ACT_RIDING_HOOT) {
src/game/interaction.c:        m->usedObj->oInteractStatus = 0;
src/game/interaction.c:        m->usedObj->oHootMarioReleaseTime = gGlobalTimer;
src/game/interaction.c:    return (m->flags & (MARIO_CAPS | MARIO_CAP_ON_HEAD)) == (MARIO_NORMAL_CAP | MARIO_CAP_ON_HEAD);
src/game/interaction.c:        m->flags &= ~(MARIO_NORMAL_CAP | MARIO_CAP_ON_HEAD);
src/game/interaction.c:        capObject = spawn_object(m->marioObj, MODEL_MARIOS_CAP, bhvNormalCap);
src/game/interaction.c:        capObject->oPosY += (m->action & ACT_FLAG_SHORT_HITBOX) ? 120.0f : 180.0f;
src/game/interaction.c:        capObject->oMoveAngleYaw = (s16)(m->faceAngle[1] + 0x400);
src/game/interaction.c:        if (m->forwardVel < 0.0f) {
src/game/interaction.c:    u32 action = m->action;
src/game/interaction.c:        if (m->actionArg < 2) {
src/game/interaction.c:    for (i = 0; i < m->marioObj->numCollidedObjs; i++) {
src/game/interaction.c:        object = m->marioObj->collidedObjs[i];
src/game/interaction.c:    if (m->input & INPUT_INTERACT_OBJ_GRABBABLE) {
src/game/interaction.c:        script = virtual_to_segmented(0x13, m->interactObj->behavior);
src/game/interaction.c:            s16 facingDYaw = m->faceAngle[1] - m->interactObj->oMoveAngleYaw;
src/game/interaction.c:                m->faceAngle[1] = m->interactObj->oMoveAngleYaw;
src/game/interaction.c:                m->usedObj = m->interactObj;
src/game/interaction.c:            s16 facingDYaw = mario_obj_angle_to_object(m, m->interactObj) - m->faceAngle[1];
src/game/interaction.c:                m->usedObj = m->interactObj;
src/game/interaction.c:                if (!(m->action & ACT_FLAG_AIR)) {
src/game/interaction.c:                        m, (m->action & ACT_FLAG_DIVING) ? ACT_DIVE_PICKING_UP : ACT_PICKING_UP, 0);
src/game/interaction.c:    m->pos[1] = o->oPosY + o->hitboxHeight;
src/game/interaction.c:    m->vel[1] = velY;
src/game/interaction.c:    m->flags &= ~MARIO_UNKNOWN_08;
src/game/interaction.c:    play_sound(SOUND_ACTION_BOUNCE_OFF_OBJECT, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    m->vel[1] = 0.0f;
src/game/interaction.c:    s16 angleToObject = mario_obj_angle_to_object(m, m->interactObj);
src/game/interaction.c:    s16 facingDYaw = angleToObject - m->faceAngle[1];
src/game/interaction.c:    if (m->forwardVel < 16.0f) {
src/game/interaction.c:        m->forwardVel = 16.0f;
src/game/interaction.c:    m->faceAngle[1] = angleToObject;
src/game/interaction.c:        m->forwardVel *= -1.0f;
src/game/interaction.c:        if (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) {
src/game/interaction.c:        m->faceAngle[1] += 0x8000;
src/game/interaction.c:        if (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) {
src/game/interaction.c:    s16 angleToObject = mario_obj_angle_to_object(m, m->interactObj);
src/game/interaction.c:    s16 facingDYaw = angleToObject - m->faceAngle[1];
src/game/interaction.c:    s16 remainingHealth = m->health - 0x40 * m->hurtCounter;
src/game/interaction.c:    if (m->action & (ACT_FLAG_SWIMMING | ACT_FLAG_METAL_WATER)) {
src/game/interaction.c:    } else if (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) {
src/game/interaction.c:    } else if (m->interactObj->oDamageOrCoinValue >= 4) {
src/game/interaction.c:    } else if (m->interactObj->oDamageOrCoinValue >= 2) {
src/game/interaction.c:    m->faceAngle[1] = angleToObject;
src/game/interaction.c:        if (m->forwardVel < 28.0f) {
src/game/interaction.c:        if (m->pos[1] >= m->interactObj->oPosY) {
src/game/interaction.c:            if (m->vel[1] < 20.0f) {
src/game/interaction.c:                m->vel[1] = 20.0f;
src/game/interaction.c:            if (m->vel[1] > 0.0f) {
src/game/interaction.c:                m->vel[1] = 0.0f;
src/game/interaction.c:        if (m->forwardVel < 16.0f) {
src/game/interaction.c:        m->forwardVel *= -1.0f;
src/game/interaction.c:        m->faceAngle[1] += 0x8000;
src/game/interaction.c:    f32 minDistance = o->hitboxRadius + m->marioObj->hitboxRadius + padding;
src/game/interaction.c:    f32 offsetX = m->pos[0] - o->oPosX;
src/game/interaction.c:    f32 offsetZ = m->pos[2] - o->oPosZ;
src/game/interaction.c:            pushAngle = m->faceAngle[1];
src/game/interaction.c:        f32_find_wall_collision(&newMarioX, &m->pos[1], &newMarioZ, 60.0f, 50.0f);
src/game/interaction.c:        find_floor(newMarioX, m->pos[1], newMarioZ, &floor);
src/game/interaction.c:            m->pos[0] = newMarioX;
src/game/interaction.c:            m->pos[2] = newMarioZ;
src/game/interaction.c:        if (m->action == ACT_PUNCHING) {
src/game/interaction.c:            m->action = ACT_MOVE_PUNCHING;
src/game/interaction.c:        if (m->action & ACT_FLAG_AIR) {
src/game/interaction.c:        m->particleFlags |= PARTICLE_TRIANGLE;
src/game/interaction.c:        play_sound(SOUND_ACTION_HIT_2, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    f32 dx = o->oPosX - m->pos[0];
src/game/interaction.c:    f32 dz = o->oPosZ - m->pos[2];
src/game/interaction.c:		if(m->interactObj->oDamageOrCoinValue==1)
src/game/interaction.c:		else if(m->interactObj->oDamageOrCoinValue==2)
src/game/interaction.c:		else if(m->interactObj->oDamageOrCoinValue>2)
src/game/interaction.c:		damage = m->interactObj->oDamageOrCoinValue;
src/game/interaction.c:    if (!(m->flags & MARIO_CAP_ON_HEAD)) {
src/game/interaction.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/interaction.c:    m->hurtCounter += 4 * damage;
src/game/interaction.c:    if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:            m->forwardVel = 40.0f;
src/game/interaction.c:            play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (m->action == ACT_WATER_JUMP || m->action == ACT_SHOT_FROM_CANNON || m->action == ACT_FLYING) {
src/game/interaction.c:        set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/interaction.c:        m->faceAngle[0] = 0;
src/game/interaction.c:    m->numCoins += o->oDamageOrCoinValue;
src/game/interaction.c:		m->healCounter += 4 * o->oDamageOrCoinValue;
src/game/interaction.c:    if (COURSE_IS_MAIN_COURSE(gCurrCourseNum) && m->numCoins - o->oDamageOrCoinValue < COINS_REQ_COINSTAR
src/game/interaction.c:        && m->numCoins >= COINS_REQ_COINSTAR) {
src/game/interaction.c:    m->healCounter += 4 * o->oDamageOrCoinValue;
src/game/interaction.c:    if (m->health >= 0x100) {
src/game/interaction.c:            m->hurtCounter = 0;
src/game/interaction.c:            m->healCounter = 0;
src/game/interaction.c:            if (m->capTimer > 1) {
src/game/interaction.c:                m->capTimer = 1;
src/game/interaction.c:        if (m->action & ACT_FLAG_SWIMMING) {
src/game/interaction.c:        if (m->action & ACT_FLAG_METAL_WATER) {
src/game/interaction.c:        if (m->action & ACT_FLAG_AIR) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:        save_file_collect_star_or_key(m->numCoins, starIndex);
src/game/interaction.c:        m->numStars =
src/game/interaction.c:        play_sound(SOUND_MENU_STAR_SOUND, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (m->action != ACT_BBH_ENTER_SPIN && m->action != ACT_BBH_ENTER_JUMP) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:        if (m->action & ACT_FLAG_AIR) {
src/game/interaction.c:        action = m->action;
src/game/interaction.c:                m->interactObj = o;
src/game/interaction.c:                m->usedObj = o;
src/game/interaction.c:        if (m->action != ACT_EMERGE_FROM_PIPE) {
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:                play_sound(SOUND_MENU_ENTER_PIPE, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:                play_sound(SOUND_MENU_ENTER_HOLE, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (m->action == ACT_WALKING || m->action == ACT_DECELERATING) {
src/game/interaction.c:        if (m->action == ACT_WALKING || m->action == ACT_DECELERATING) {
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:    if (m->action == ACT_WALKING || m->action == ACT_DECELERATING) {
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:    } else if (m->action == ACT_IDLE && sDisplayingDoorText == TRUE && requiredNumStars == 70) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:    if (m->action != ACT_IN_CANNON) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:    m->interactObj = o;
src/game/interaction.c:    m->usedObj = o;
src/game/interaction.c:    struct Object *marioObj = m->marioObj;
src/game/interaction.c:    if (m->action != ACT_TORNADO_TWIRLING && m->action != ACT_SQUISHED) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:        marioObj->oMarioTornadoPosY = m->pos[1] - o->oPosY;
src/game/interaction.c:        play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        return set_mario_action(m, ACT_TORNADO_TWIRLING, m->action == ACT_TWIRLING);
src/game/interaction.c:    struct Object *marioObj = m->marioObj;
src/game/interaction.c:    if (m->action != ACT_CAUGHT_IN_WHIRLPOOL) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:        m->forwardVel = 0.0f;
src/game/interaction.c:        marioObj->oMarioWhirlpoolPosY = m->pos[1] - o->oPosY;
src/game/interaction.c:        play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    UNUSED struct Object *marioObj = m->marioObj;
src/game/interaction.c:    if (m->action != ACT_GETTING_BLOWN) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:        m->faceAngle[1] = o->oMoveAngleYaw + 0x8000;
src/game/interaction.c:        m->unkC4 = 0.4f;
src/game/interaction.c:        m->forwardVel = -24.0f;
src/game/interaction.c:        m->vel[1] = 12.0f;
src/game/interaction.c:        play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (!sInvulnerable && !(m->flags & MARIO_METAL_CAP) && !(m->flags & MARIO_VANISH_CAP)
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        if ((m->action & (ACT_FLAG_SWIMMING | ACT_FLAG_METAL_WATER))
src/game/interaction.c:            || m->waterLevel - m->pos[1] > 50.0f) {
src/game/interaction.c:            play_sound(SOUND_GENERAL_FLAME_OUT, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:            m->marioObj->oMarioBurnTimer = 0;
src/game/interaction.c:            play_sound(SOUND_MARIO_ON_FIRE, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:            if ((m->action & ACT_FLAG_AIR) && m->vel[1] <= 0.0f) {
src/game/interaction.c:    if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)) {
src/game/interaction.c:        if (m->flags & MARIO_METAL_CAP) {
src/game/interaction.c:            play_sound(SOUND_ACTION_UNKNOWN458, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/interaction.c:    m->interactObj = o;
src/game/interaction.c:        m->forwardVel = -16.0f;
src/game/interaction.c:        o->oMoveAngleYaw = m->faceAngle[1];
src/game/interaction.c:    else if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)
src/game/interaction.c:        m->invincTimer = 2;
src/game/interaction.c:        play_sound(SOUND_MARIO_EEUH, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        play_sound(SOUND_OBJ_BULLY_METAL, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)
src/game/interaction.c:        u32 actionArg = (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) == 0;
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        if (m->action & (ACT_FLAG_SWIMMING | ACT_FLAG_METAL_WATER)) {
src/game/interaction.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/interaction.c:                play_sound(SOUND_MARIO_TWIRL_BOUNCE, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/interaction.c:                play_sound(SOUND_MARIO_TWIRL_BOUNCE, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:    if (!(m->action & ACT_FLAG_RIDING_SHELL)) {
src/game/interaction.c:        if (interaction == INT_HIT_FROM_ABOVE || m->action == ACT_WALKING
src/game/interaction.c:            || m->action == ACT_HOLD_WALKING) {
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:            m->riddenObj = o;
src/game/interaction.c:    if ((!(m->action & (ACT_FLAG_AIR | ACT_FLAG_INVULNERABLE | ACT_FLAG_ATTACKING)) || !sInvulnerable)
src/game/interaction.c:            m->faceAngle[1] = o->oMoveAngleYaw;
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:            play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    s32 actionId = m->action & ACT_ID_MASK;
src/game/interaction.c:        if (!(m->prevAction & ACT_FLAG_ON_POLE) || m->usedObj != o) {
src/game/interaction.c:            u32 lowSpeed = (m->forwardVel <= 10.0f);
src/game/interaction.c:            struct Object *marioObj = m->marioObj;
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:            m->vel[1] = 0.0f;
src/game/interaction.c:            m->forwardVel = 0.0f;
src/game/interaction.c:            marioObj->oMarioPolePos = (m->pos[1] - o->oPosY) < 0
src/game/interaction.c:                : (m->pos[1] - o->oPosY);
src/game/interaction.c:            //! @bug Using m->forwardVel here is assumed to be 0.0f due to the set from earlier.
src/game/interaction.c:            marioObj->oMarioPoleYawVel = (s32)(m->forwardVel * 0x100 + 0x1000);
src/game/interaction.c:    s32 actionId = m->action & ACT_ID_MASK;
src/game/interaction.c:        && (gGlobalTimer - m->usedObj->oHootMarioReleaseTime > 30)) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:    if (m->action != ACT_GETTING_BLOWN && capFlag != 0) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->flags &= ~MARIO_CAP_ON_HEAD & ~MARIO_CAP_IN_HAND;
src/game/interaction.c:        m->flags |= capFlag;
src/game/interaction.c:        if (capTime > m->capTimer) {
src/game/interaction.c:            m->capTimer = capTime;
src/game/interaction.c:        if ((m->action & ACT_FLAG_IDLE) || m->action == ACT_WALKING) {
src/game/interaction.c:            m->flags |= MARIO_CAP_IN_HAND;
src/game/interaction.c:            m->flags |= MARIO_CAP_ON_HEAD;
src/game/interaction.c:        play_sound(SOUND_MENU_STAR_SOUND, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->input |= INPUT_INTERACT_OBJ_GRABBABLE;
src/game/interaction.c:    if ((m->action & ACT_FLAG_IDLE) != 0x00000000) {
src/game/interaction.c:    if (m->action == ACT_WALKING) {
src/game/interaction.c:        val6 = m->marioObj->header.gfx.animInfo.animID;
src/game/interaction.c:    if ((m->input & READ_MASK) && mario_can_talk(m, 0) && object_facing_mario(m, o, SIGN_RANGE)) {
src/game/interaction.c:        s16 facingDYaw = (s16)(o->oMoveAngleYaw + 0x8000) - m->faceAngle[1];
src/game/interaction.c:            m->marioObj->oMarioReadingSignDYaw = facingDYaw;
src/game/interaction.c:            m->marioObj->oMarioReadingSignDPosX = targetX - m->pos[0];
src/game/interaction.c:            m->marioObj->oMarioReadingSignDPosZ = targetZ - m->pos[2];
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:    if ((m->input & READ_MASK) && mario_can_talk(m, 0) && object_facing_mario(m, o, SIGN_RANGE)) {
src/game/interaction.c:        s16 facingDYaw = (s16)(o->oMoveAngleYaw + 0x8000) - m->faceAngle[1];
src/game/interaction.c:            m->marioObj->oMarioReadingSignDYaw = facingDYaw;
src/game/interaction.c:            m->marioObj->oMarioReadingSignDPosX = targetX - m->pos[0];
src/game/interaction.c:            m->marioObj->oMarioReadingSignDPosZ = targetZ - m->pos[2];
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:    if ((m->input & READ_MASK) && mario_can_talk(m, 1)) {
src/game/interaction.c:        s16 facingDYaw = mario_obj_angle_to_object(m, o) - m->faceAngle[1];
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:    if (m->flags & (MARIO_PUNCHING | MARIO_KICKING | MARIO_TRIPPING)) {
src/game/interaction.c:        detector[0] = m->pos[0] + 50.0f * sins(m->faceAngle[1]);
src/game/interaction.c:        detector[2] = m->pos[2] + 50.0f * coss(m->faceAngle[1]);
src/game/interaction.c:        detector[1] = m->pos[1];
src/game/interaction.c:            if (m->action != ACT_MOVE_PUNCHING || m->forwardVel >= 0.0f) {
src/game/interaction.c:                if (m->action == ACT_PUNCHING) {
src/game/interaction.c:                    m->action = ACT_MOVE_PUNCHING;
src/game/interaction.c:                play_sound(SOUND_ACTION_HIT_2, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:                m->particleFlags |= PARTICLE_TRIANGLE;
src/game/interaction.c:            } else if (m->action & ACT_FLAG_AIR) {
src/game/interaction.c:                play_sound(SOUND_ACTION_HIT_2, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:                m->particleFlags |= PARTICLE_TRIANGLE;
src/game/interaction.c:    sInvulnerable = (m->action & ACT_FLAG_INVULNERABLE) || m->invincTimer != 0;
src/game/interaction.c:    if (!(m->action & ACT_FLAG_INTANGIBLE) && m->collidedObjInteractTypes != 0) {
src/game/interaction.c:            if (m->collidedObjInteractTypes & interactType) {
src/game/interaction.c:                m->collidedObjInteractTypes &= ~interactType;
src/game/interaction.c:    if (m->invincTimer > 0 && !sDelayInvincTimer) {
src/game/interaction.c:        m->invincTimer -= 1;
src/game/interaction.c:    m->flags &= ~MARIO_PUNCHING & ~MARIO_KICKING & ~MARIO_TRIPPING;
src/game/interaction.c:    if (!(m->marioObj->collidedObjInteractTypes & (INTERACT_WARP_DOOR | INTERACT_DOOR))) {
src/game/interaction.c:    if (!(m->marioObj->collidedObjInteractTypes & INTERACT_WARP)) {
src/game/interaction.c:    if (m->pos[1] < m->floorHeight + 2048.0f) {
src/game/interaction.c:        if (level_trigger_warp(m, WARP_OP_WARP_FLOOR) == 20 && !(m->flags & MARIO_UNKNOWN_18)) {
src/game/interaction.c:            play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (!(m->action & ACT_FLAG_RIDING_SHELL) && m->pos[1] < m->floorHeight + 10.0f) {
src/game/interaction.c:        if (!(m->flags & MARIO_METAL_CAP)) {
src/game/interaction.c:            m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
src/game/interaction.c:            m->marioObj->oBehParams = (1 << 24);
src/game/interaction.c:    if ((m->action & ACT_GROUP_MASK) == ACT_GROUP_CUTSCENE) {
src/game/interaction.c:    if (m->floor != NULL) {
src/game/interaction.c:        s32 floorType = m->floor->type;
src/game/interaction.c:        if (!(m->action & ACT_FLAG_AIR) && !(m->action & ACT_FLAG_SWIMMING)) {
src/game/level_geo.c:        gfx = create_skybox_facing_camera(0, backgroundNode->background, camFrustum->fov, gLakituState.pos[0],
src/game/level_update.c:            m->flags |= MARIO_METAL_CAP | MARIO_CAP_ON_HEAD;
src/game/level_update.c:            m->capTimer = MC_LEVEL_TIME;
src/game/level_update.c:            m->flags |= MARIO_WING_CAP | MARIO_CAP_ON_HEAD;
src/game/level_update.c:            m->capTimer = WC_LEVEL_TIME;
src/game/level_update.c:            m->flags |= MARIO_VANISH_CAP | MARIO_CAP_ON_HEAD;
src/game/level_update.c:            m->capTimer = VC_LEVEL_TIME;
src/game/level_update.c:        m->invincTimer = -1;
src/game/level_update.c:				if (m->numLives == 0 && INFINITE_LIVES) {
src/game/level_update.c:                    if (m->numLives == 0 && !INFINITE_LIVES) {
src/game/level_update.c:                sSourceWarpNodeId = (m->usedObj->oBehParams & 0x00FF0000) >> 16;
src/game/level_update.c:                sSourceWarpNodeId = (m->usedObj->oBehParams & 0x00FF0000) >> 16;
src/game/level_update.c:                sDelayedWarpArg = m->actionArg;
src/game/level_update.c:                sSourceWarpNodeId = (m->usedObj->oBehParams & 0x00FF0000) >> 16;
src/game/level_update.c:                sSourceWarpNodeId = (m->usedObj->oBehParams & 0x00FF0000) >> 16;
src/game/mario.c:    struct Object *o = m->marioObj;
src/game/mario.c:    return (o->header.gfx.animInfo.animFrame + 1) == o->header.gfx.animInfo.curAnim->loopEnd;
src/game/mario.c:    struct Object *o = m->marioObj;
src/game/mario.c:    return o->header.gfx.animInfo.animFrame >= (o->header.gfx.animInfo.curAnim->loopEnd - 2);
src/game/mario.c:    struct Object *o = m->marioObj;
src/game/mario.c:    struct Animation *targetAnim = m->animation->targetAnim;
src/game/mario.c:    if (load_patchable_table(m->animation, targetAnimID)) {
src/game/mario.c:        targetAnim->values = (void *) VIRTUAL_TO_PHYSICAL((u8 *) targetAnim + (uintptr_t) targetAnim->values);
src/game/mario.c:        targetAnim->index = (void *) VIRTUAL_TO_PHYSICAL((u8 *) targetAnim + (uintptr_t) targetAnim->index);
src/game/mario.c:        o->header.gfx.animInfo.animYTrans = m->unkB0;
src/game/mario.c:        if (targetAnim->flags & ANIM_FLAG_2) {
src/game/mario.c:            o->header.gfx.animInfo.animFrame = targetAnim->startFrame;
src/game/mario.c:            if (targetAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:                o->header.gfx.animInfo.animFrame = targetAnim->startFrame + 1;
src/game/mario.c:                o->header.gfx.animInfo.animFrame = targetAnim->startFrame - 1;
src/game/mario.c:    struct Object *o = m->marioObj;
src/game/mario.c:    struct Animation *targetAnim = m->animation->targetAnim;
src/game/mario.c:    if (load_patchable_table(m->animation, targetAnimID)) {
src/game/mario.c:        targetAnim->values = (void *) VIRTUAL_TO_PHYSICAL((u8 *) targetAnim + (uintptr_t) targetAnim->values);
src/game/mario.c:        targetAnim->index = (void *) VIRTUAL_TO_PHYSICAL((u8 *) targetAnim + (uintptr_t) targetAnim->index);
src/game/mario.c:        o->header.gfx.animInfo.animYTrans = m->unkB0;
src/game/mario.c:        if (targetAnim->flags & ANIM_FLAG_2) {
src/game/mario.c:            o->header.gfx.animInfo.animFrameAccelAssist = (targetAnim->startFrame << 0x10);
src/game/mario.c:            if (targetAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:                o->header.gfx.animInfo.animFrameAccelAssist = (targetAnim->startFrame << 0x10) + accel;
src/game/mario.c:                o->header.gfx.animInfo.animFrameAccelAssist = (targetAnim->startFrame << 0x10) - accel;
src/game/mario.c:    struct AnimInfo *animInfo = &m->marioObj->header.gfx.animInfo;
src/game/mario.c:        if (curAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:        if (curAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:    struct AnimInfo *animInfo = &m->marioObj->header.gfx.animInfo;
src/game/mario.c:        if (curAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:        if (curAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:    u16 *animIndex = segmented_to_virtual((void *) curAnim->index);
src/game/mario.c:    s16 *animValues = segmented_to_virtual((void *) curAnim->values);
src/game/mario.c:    return curAnim->flags;
src/game/mario.c:    flags = find_mario_anim_flags_and_translation(m->marioObj, m->faceAngle[1], translation);
src/game/mario.c:        m->pos[0] += (f32) translation[0];
src/game/mario.c:        m->pos[2] += (f32) translation[2];
src/game/mario.c:        m->pos[1] += (f32) translation[1];
src/game/mario.c:    find_mario_anim_flags_and_translation(m->marioObj, 0, translation);
src/game/mario.c:    if (!(m->flags & flags)) {
src/game/mario.c:        play_sound(soundBits, m->marioObj->header.gfx.cameraToObject);
src/game/mario.c:        m->flags |= flags;
src/game/mario.c:    if (!(m->flags & MARIO_MARIO_SOUND_PLAYED)) {
src/game/mario.c:        if (m->action == ACT_TRIPLE_JUMP) {
src/game/mario.c:                       m->marioObj->header.gfx.cameraToObject);
src/game/mario.c:                       m->marioObj->header.gfx.cameraToObject);
src/game/mario.c:        m->flags |= MARIO_MARIO_SOUND_PLAYED;
src/game/mario.c:    s32 absForwardVel = (m->forwardVel > 0.0f) ? m->forwardVel : -m->forwardVel;
src/game/mario.c:    if (m->terrainSoundAddend == (SOUND_TERRAIN_WATER << 16)) {
src/game/mario.c:            m->particleFlags |= PARTICLE_SHALLOW_WATER_SPLASH;
src/game/mario.c:            m->particleFlags |= PARTICLE_SHALLOW_WATER_WAVE;
src/game/mario.c:        if (m->terrainSoundAddend == (SOUND_TERRAIN_SAND << 16)) {
src/game/mario.c:            m->particleFlags |= PARTICLE_DIRT;
src/game/mario.c:        } else if (m->terrainSoundAddend == (SOUND_TERRAIN_SNOW << 16)) {
src/game/mario.c:            m->particleFlags |= PARTICLE_SNOW;
src/game/mario.c:    if ((m->flags & MARIO_METAL_CAP) || soundBits == SOUND_ACTION_UNSTUCK_FROM_GROUND
src/game/mario.c:        play_sound(soundBits, m->marioObj->header.gfx.cameraToObject);
src/game/mario.c:        play_sound(m->terrainSoundAddend + soundBits, m->marioObj->header.gfx.cameraToObject);
src/game/mario.c:    if (!(m->flags & MARIO_ACTION_SOUND_PLAYED)) {
src/game/mario.c:        m->flags |= MARIO_ACTION_SOUND_PLAYED;
src/game/mario.c:        m, (m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_LANDING : soundBits, 1);
src/game/mario.c:        m, (m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_LANDING : soundBits, 1);
src/game/mario.c:        m, (m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_HEAVY_LANDING : soundBits, 1);
src/game/mario.c:        m, (m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_HEAVY_LANDING : soundBits, 1);
src/game/mario.c:        play_mario_action_sound(m, (m->flags & MARIO_METAL_CAP) ? (s32) SOUND_ACTION_METAL_JUMP
src/game/mario.c:    m->forwardVel = forwardVel;
src/game/mario.c:    m->slideVelX = sins(m->faceAngle[1]) * m->forwardVel;
src/game/mario.c:    m->slideVelZ = coss(m->faceAngle[1]) * m->forwardVel;
src/game/mario.c:    m->vel[0] = (f32) m->slideVelX;
src/game/mario.c:    m->vel[2] = (f32) m->slideVelZ;
src/game/mario.c:    if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE) {
src/game/mario.c:    if (m->floor != NULL) {
src/game/mario.c:        switch (m->floor->type) {
src/game/mario.c:    if (m->action == ACT_CRAWLING && m->floor->normal.y > 0.5f && floorClass == SURFACE_CLASS_DEFAULT) {
src/game/mario.c:    s16 terrainType = m->area->terrainType & TERRAIN_MASK;
src/game/mario.c:    if (m->floor != NULL) {
src/game/mario.c:        floorType = m->floor->type;
src/game/mario.c:        if ((gCurrLevelNum != LEVEL_LLL) && (m->floorHeight < (m->waterLevel - 10))) {
src/game/mario.c:    s16 faceAngleYaw = m->faceAngle[1];
src/game/mario.c:    if (turnYaw && m->forwardVel < 0.0f) {
src/game/mario.c:    faceAngleYaw = m->floorAngle - faceAngleYaw;
src/game/mario.c:    if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE
src/game/mario.c:        && m->floor->normal.y < 0.9998477f //~cos(1 deg)
src/game/mario.c:    return m->floor->normal.y <= normY;
src/game/mario.c:    if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE
src/game/mario.c:        && m->floor->normal.y < 0.9998477f) { // ~cos(1 deg)
src/game/mario.c:    return m->floor->normal.y <= normY;
src/game/mario.c:        result = m->floor->normal.y <= normY;
src/game/mario.c:    f32 y = sins(m->faceAngle[1] + angleFromMario) * distFromMario;
src/game/mario.c:    f32 x = coss(m->faceAngle[1] + angleFromMario) * distFromMario;
src/game/mario.c:    floorY = find_floor(m->pos[0] + y, m->pos[1] + 100.0f, m->pos[2] + x, &floor);
src/game/mario.c:    f32 x = sins(m->faceAngle[1] + yawOffset) * 5.0f;
src/game/mario.c:    f32 z = coss(m->faceAngle[1] + yawOffset) * 5.0f;
src/game/mario.c:    forwardFloorY = find_floor(m->pos[0] + x, m->pos[1] + 100.0f, m->pos[2] + z, &floor);
src/game/mario.c:    backwardFloorY = find_floor(m->pos[0] - x, m->pos[1] + 100.0f, m->pos[2] - z, &floor);
src/game/mario.c:    forwardYDelta = forwardFloorY - m->pos[1];
src/game/mario.c:    backwardYDelta = m->pos[1] - backwardFloorY;
src/game/mario.c:    u32 action = m->action;
src/game/mario.c:    s32 camPreset = m->area->camera->mode;
src/game/mario.c:        set_camera_mode(m->area->camera, -1, 1);
src/game/mario.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario.c:    m->marioObj->oMarioSteepJumpYaw = m->faceAngle[1];
src/game/mario.c:    if (m->forwardVel > 0.0f) {
src/game/mario.c:        // undefined behavior if m->floorAngle >= 0.
src/game/mario.c:        s16 angleTemp = m->floorAngle + 0x8000;
src/game/mario.c:        s16 faceAngleTemp = m->faceAngle[1] - angleTemp;
src/game/mario.c:        f32 y = sins(faceAngleTemp) * m->forwardVel;
src/game/mario.c:        f32 x = coss(faceAngleTemp) * m->forwardVel * 0.75f;
src/game/mario.c:        m->forwardVel = sqrtf(y * y + x * x);
src/game/mario.c:        m->faceAngle[1] = atan2s(x, y) + angleTemp;
src/game/mario.c:    m->vel[1] = initialVelY + get_additive_y_vel_for_jumps() + m->forwardVel * multiplier;
src/game/mario.c:    if (m->squishTimer != 0 || m->quicksandDepth > 1.0f) {
src/game/mario.c:        m->vel[1] *= 0.5f;
src/game/mario.c:    if ((m->squishTimer != 0 || m->quicksandDepth >= 1.0f)
src/game/mario.c:            m->forwardVel *= 0.8f;
src/game/mario.c:            m->marioObj->header.gfx.animInfo.animID = -1;
src/game/mario.c:            m->forwardVel = -16.0f;
src/game/mario.c:            m->forwardVel *= 0.8f;
src/game/mario.c:            m->vel[1] = 31.5f;
src/game/mario.c:            m->forwardVel = 8.0f;
src/game/mario.c:            m->marioObj->header.gfx.animInfo.animID = -1;
src/game/mario.c:            m->forwardVel *= 0.8f;
src/game/mario.c:            if (m->forwardVel < 24.0f) {
src/game/mario.c:                m->forwardVel = 24.0f;
src/game/mario.c:            m->wallKickTimer = 0;
src/game/mario.c:            m->forwardVel = 8.0f;
src/game/mario.c:            m->faceAngle[1] = m->intendedYaw;
src/game/mario.c:            m->marioObj->header.gfx.animInfo.animID = -1;
src/game/mario.c:            m->faceAngle[0] = -0x2000;
src/game/mario.c:            m->vel[1] = 84.0f;
src/game/mario.c:                m->forwardVel = 0.0f;
src/game/mario.c:            if ((fowardVel = m->forwardVel + 15.0f) > 48.0f) {
src/game/mario.c:            m->marioObj->header.gfx.animInfo.animID = -1;
src/game/mario.c:            m->marioObj->oMarioLongJumpIsSlow = m->forwardVel > 16.0f ? FALSE : TRUE;
src/game/mario.c:            if ((m->forwardVel *= 1.5f) > 48.0f) {
src/game/mario.c:                m->forwardVel = 48.0f;
src/game/mario.c:            m->vel[1] = 12.0f;
src/game/mario.c:            if (m->forwardVel < 32.0f) {
src/game/mario.c:                m->forwardVel = 32.0f;
src/game/mario.c:            m->vel[1] = 20.0f;
src/game/mario.c:    m->peakHeight = m->pos[1];
src/game/mario.c:    m->flags |= MARIO_UNKNOWN_08;
src/game/mario.c:    f32 forwardVel = m->forwardVel;
src/game/mario.c:    f32 mag = min(m->intendedMag, 8.0f);
src/game/mario.c:                    m->forwardVel = mag;
src/game/mario.c:            m->marioObj->oMarioWalkingPitch = 0;
src/game/mario.c:                m->forwardVel = mag / 2.0f;
src/game/mario.c:        m->vel[1] = 32.0f;
src/game/mario.c:            m->vel[1] = 52.0f;
src/game/mario.c:            m->vel[1] = 64.0f;
src/game/mario.c:    m->flags &= ~(MARIO_ACTION_SOUND_PLAYED | MARIO_MARIO_SOUND_PLAYED);
src/game/mario.c:    if (!(m->action & ACT_FLAG_AIR)) {
src/game/mario.c:        m->flags &= ~MARIO_UNKNOWN_18;
src/game/mario.c:    m->prevAction = m->action;
src/game/mario.c:    m->action = action;
src/game/mario.c:    m->actionArg = actionArg;
src/game/mario.c:    m->actionState = 0;
src/game/mario.c:    m->actionTimer = 0;
src/game/mario.c:    if (m->quicksandDepth >= 11.0f) {
src/game/mario.c:        if (m->heldObj == NULL) {
src/game/mario.c:        if ((m->doubleJumpTimer == 0) || (m->squishTimer != 0)) {
src/game/mario.c:            switch (m->prevAction) {
src/game/mario.c:                    if (m->flags & MARIO_WING_CAP) {
src/game/mario.c:                    } else if (m->forwardVel > 20.0f) {
src/game/mario.c:    m->doubleJumpTimer = 0;
src/game/mario.c:    UNUSED u32 currAction = m->action;
src/game/mario.c:    if (m->quicksandDepth >= 11.0f) {
src/game/mario.c:        if (m->heldObj == NULL) {
src/game/mario.c:    m->hurtCounter = hurtCounter;
src/game/mario.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario.c:    set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario.c:    vec3s_set(m->angleVel, 0, 0, 0);
src/game/mario.c:    if (m->heldObj == NULL) {
src/game/mario.c:    m->forwardVel = m->forwardVel / 4.0f;
src/game/mario.c:    m->vel[1] = m->vel[1] / 2.0f;
src/game/mario.c:    // m->pos[1] = m->waterLevel - 100;
src/game/mario.c:    m->faceAngle[2] = 0;
src/game/mario.c:    vec3s_set(m->angleVel, 0, 0, 0);
src/game/mario.c:    if (!(m->action & ACT_FLAG_DIVING)) {
src/game/mario.c:        m->faceAngle[0] = 0;
src/game/mario.c:    if (m->area->camera->mode != CAMERA_MODE_WATER_SURFACE) {
src/game/mario.c:        set_camera_mode(m->area->camera, CAMERA_MODE_WATER_SURFACE, 1);
src/game/mario.c:    if (m->squishTimer != 0xFF) {
src/game/mario.c:        if (m->squishTimer == 0) {
src/game/mario.c:                    vec3f_set(m->marioObj->header.gfx.scale, 2.5f, 2.5f, 2.5f);
src/game/mario.c:                    vec3f_set(m->marioObj->header.gfx.scale, 0.2f, 0.2f, 0.2f);
src/game/mario.c:                    vec3f_set(m->marioObj->header.gfx.scale, 1.0f, 1.0f, 1.0f);
src/game/mario.c:					if (m->Chaos_Vals[0]<5 | m->Chaos_Vals[1]<5){
src/game/mario.c:						vec3f_set(m->marioObj->header.gfx.scale, Mscale, Mscale, Mscale);
src/game/mario.c:					vec3f_set(m->marioObj->header.gfx.scale, Mscale, Mscale, Mscale);
src/game/mario.c:        else if (m->squishTimer <= 16) {
src/game/mario.c:            m->squishTimer -= 1;
src/game/mario.c:            m->marioObj->header.gfx.scale[1] =
src/game/mario.c:                1.0f - ((sSquishScaleOverTime[15 - m->squishTimer] * 0.6f) / 100.0f);
src/game/mario.c:            m->marioObj->header.gfx.scale[0] =
src/game/mario.c:                ((sSquishScaleOverTime[15 - m->squishTimer] * 0.4f) / 100.0f) + 1.0f;
src/game/mario.c:            m->marioObj->header.gfx.scale[2] = m->marioObj->header.gfx.scale[0];
src/game/mario.c:            m->squishTimer -= 1;
src/game/mario.c:            vec3f_set(m->marioObj->header.gfx.scale, 1.4f, 0.4f, 1.4f);
src/game/mario.c:            ((m->floor->normal.x * m->floor->normal.x) + (m->floor->normal.z * m->floor->normal.z)));
src/game/mario.c:        floor_nY = m->floor->normal.y;
src/game/mario.c:        print_text_fmt_int(210, 72, "SPD %d", m->forwardVel);
src/game/mario.c:        print_text_fmt_int(210, 56, "STA %x", (m->action & ACT_ID_MASK));
src/game/mario.c:    if (m->controller->buttonPressed & A_BUTTON) {
src/game/mario.c:        m->input |= INPUT_A_PRESSED;
src/game/mario.c:    if (m->controller->buttonDown & A_BUTTON) {
src/game/mario.c:        m->input |= INPUT_A_DOWN;
src/game/mario.c:    if (m->squishTimer == 0) {
src/game/mario.c:        if (m->controller->buttonPressed & B_BUTTON) {
src/game/mario.c:            m->input |= INPUT_B_PRESSED;
src/game/mario.c:        if (m->controller->buttonDown & Z_TRIG) {
src/game/mario.c:            m->input |= INPUT_Z_DOWN;
src/game/mario.c:        if (m->controller->buttonPressed & Z_TRIG) {
src/game/mario.c:            m->input |= INPUT_Z_PRESSED;
src/game/mario.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario.c:        m->framesSinceA = 0;
src/game/mario.c:    } else if (m->framesSinceA < 0xFF) {
src/game/mario.c:        m->framesSinceA += 1;
src/game/mario.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario.c:        m->framesSinceB = 0;
src/game/mario.c:    } else if (m->framesSinceB < 0xFF) {
src/game/mario.c:        m->framesSinceB += 1;
src/game/mario.c:    struct Controller *controller = m->controller;
src/game/mario.c:    if (m->squishTimer == 0) {
src/game/mario.c:        m->intendedMag = mag / 2.0f;
src/game/mario.c:        m->intendedMag = mag / 8.0f;
src/game/mario.c:    if (m->intendedMag > 0.0f) {
src/game/mario.c:        m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
src/game/mario.c:            m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
src/game/mario.c:            m->intendedYaw = atan2s(-controller->stickY, controller->stickX)-newcam_yaw+0x4000;
src/game/mario.c:        m->input |= INPUT_NONZERO_ANALOG;
src/game/mario.c:        m->intendedYaw = m->faceAngle[1];
src/game/mario.c:    f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 60.0f*mScale, 50.0f*mScale);
src/game/mario.c:    f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 30.0f*mScale, 24.0f*mScale);
src/game/mario.c:    m->floorHeight = find_floor(m->pos[0], m->pos[1], m->pos[2], &m->floor);
src/game/mario.c:    if (m->floor == NULL) {
src/game/mario.c:        vec3f_copy(m->pos, m->marioObj->header.gfx.pos);
src/game/mario.c:        m->floorHeight = find_floor(m->pos[0], m->pos[1], m->pos[2], &m->floor);
src/game/mario.c:    m->ceilHeight = vec3f_find_ceil(&m->pos[0], m->pos[1], &m->ceil);
src/game/mario.c:    gasLevel = find_poison_gas_level(m->pos[0], m->pos[2]);
src/game/mario.c:    m->waterLevel = find_water_level(m->pos[0], m->pos[2]);
src/game/mario.c:    if (m->floor != NULL) {
src/game/mario.c:        m->floorAngle = atan2s(m->floor->normal.z, m->floor->normal.x);
src/game/mario.c:        m->terrainSoundAddend = mario_get_terrain_sound_addend(m);
src/game/mario.c:        if ((m->pos[1] > m->waterLevel - 40) && mario_floor_is_slippery(m)) {
src/game/mario.c:            m->input |= INPUT_ABOVE_SLIDE;
src/game/mario.c:        if ((m->floor->flags & SURFACE_FLAG_DYNAMIC)
src/game/mario.c:            || (m->ceil && m->ceil->flags & SURFACE_FLAG_DYNAMIC)) {
src/game/mario.c:            ceilToFloorDist = m->ceilHeight - m->floorHeight;
src/game/mario.c:                m->input |= INPUT_SQUISHED;
src/game/mario.c:        if (m->pos[1] > m->floorHeight + 100.0f*mScale) {
src/game/mario.c:            m->input |= INPUT_OFF_FLOOR;
src/game/mario.c:        if (m->pos[1] < (m->waterLevel - 10*mScale)) {
src/game/mario.c:            m->input |= INPUT_IN_WATER;
src/game/mario.c:        if (m->pos[1] < (gasLevel - 100.0f*mScale)) {
src/game/mario.c:            m->input |= INPUT_IN_POISON_GAS;
src/game/mario.c:    m->particleFlags = 0;
src/game/mario.c:    m->input = 0;
src/game/mario.c:    m->collidedObjInteractTypes = m->marioObj->collidedObjInteractTypes;
src/game/mario.c:    m->flags &= 0xFFFFFF;
src/game/mario.c:    while (Cheats.MoonJump == true && Cheats.EnableCheats == true && m->controller->buttonDown & L_TRIG ){
src/game/mario.c:        m->vel[1] = 25;
src/game/mario.c:        if (m->action & ACT_FLAG_ALLOW_FIRST_PERSON) {
src/game/mario.c:            m->input |= INPUT_FIRST_PERSON;
src/game/mario.c:    if (!(m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED))) {
src/game/mario.c:        m->input |= INPUT_UNKNOWN_5;
src/game/mario.c:    if (m->marioObj->oInteractStatus
src/game/mario.c:        m->input |= INPUT_UNKNOWN_10;
src/game/mario.c:    if (m->wallKickTimer > 0) {
src/game/mario.c:        m->wallKickTimer--;
src/game/mario.c:    if (m->doubleJumpTimer > 0) {
src/game/mario.c:        m->doubleJumpTimer--;
src/game/mario.c:    if ((m->action & ACT_GROUP_MASK) == ACT_GROUP_SUBMERGED) {
src/game/mario.c:        heightBelowWater = (f32)(m->waterLevel - 80) - m->pos[1];
src/game/mario.c:        camPreset = m->area->camera->mode;
src/game/mario.c:        if (m->action & ACT_FLAG_METAL_WATER) {
src/game/mario.c:                set_camera_mode(m->area->camera, CAMERA_MODE_CLOSE, 1);
src/game/mario.c:                set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
src/game/mario.c:                set_camera_mode(m->area->camera, CAMERA_MODE_WATER_SURFACE, 1);
src/game/mario.c:            if (!(m->action & ACT_FLAG_INTANGIBLE)) {
src/game/mario.c:                if ((m->pos[1] < (f32)(m->waterLevel - 160)) || (m->faceAngle[0] < -0x800)) {
src/game/mario.c:                    m->particleFlags |= PARTICLE_BUBBLE;
src/game/mario.c:    if (m->health >= 0x100) {
src/game/mario.c:				m->health -= 1;
src/game/mario.c:					m->health -= 0x100;
src/game/mario.c:					m->health -= 0x100;
src/game/mario.c:					m->health -= 0x100;
src/game/mario.c:        if (((u32) m->healCounter | (u32) m->hurtCounter) == 0) {
src/game/mario.c:            if ((m->input & INPUT_IN_POISON_GAS) && !(m->action & ACT_FLAG_INTANGIBLE)) {
src/game/mario.c:                if (!(m->flags & MARIO_METAL_CAP) && !gDebugLevelSelect) {
src/game/mario.c:                    m->health -= 4;
src/game/mario.c:                if ((m->action & ACT_FLAG_SWIMMING) && !(m->action & ACT_FLAG_INTANGIBLE)) {
src/game/mario.c:                    terrainIsSnow = (m->area->terrainType & TERRAIN_MASK) == TERRAIN_SNOW;
src/game/mario.c:						if ((m->pos[1] >= (m->waterLevel - 140)) && !terrainIsSnow) {
src/game/mario.c:							m->health += 0x1A;
src/game/mario.c:							m->health -= (terrainIsSnow ? 3 : 1);
src/game/mario.c:        if (m->healCounter > 0) {
src/game/mario.c:            m->health += 0x40;
src/game/mario.c:            m->healCounter--;
src/game/mario.c:        if (m->hurtCounter > 0) {
src/game/mario.c:            m->health -= 0x40;
src/game/mario.c:            m->hurtCounter--;
src/game/mario.c:			if (m->health > 0x180) {
src/game/mario.c:				m->health = 0x180;
src/game/mario.c:			if (m->health > MAXHP) {
src/game/mario.c:				m->health = MAXHP;
src/game/mario.c:        if (m->health < 0x100) {
src/game/mario.c:            m->health = 0xFF;
src/game/mario.c:			if (((m->action & ACT_GROUP_MASK) == ACT_GROUP_SUBMERGED) && (m->health < 0x300)) {
src/game/mario.c:    m->marioBodyState->action = m->action;
src/game/mario.c:    m->statusForCamera->action = m->action;
src/game/mario.c:    vec3s_copy(m->statusForCamera->faceAngle, m->faceAngle);
src/game/mario.c:    if (!(m->flags & MARIO_UNKNOWN_25)) {
src/game/mario.c:        vec3f_copy(m->statusForCamera->pos, m->pos);
src/game/mario.c:    struct MarioBodyState *bodyState = m->marioBodyState;
src/game/mario.c:    m->flags &= ~MARIO_METAL_SHOCK;
src/game/mario.c:    struct Object *o = m->marioObj;
src/game/mario.c:        (*o->header.gfx.throwMatrix)[3][1] -= m->quicksandDepth;
src/game/mario.c:    o->header.gfx.pos[1] -= m->quicksandDepth;
src/game/mario.c:    u32 flags = m->flags;
src/game/mario.c:    if (m->capTimer > 0) {
src/game/mario.c:        action = m->action;
src/game/mario.c:        if ((m->capTimer <= 60)
src/game/mario.c:            m->capTimer -= 1;
src/game/mario.c:        if (m->capTimer == 0) {
src/game/mario.c:            m->flags &= ~MARIO_SPECIAL_CAPS;
src/game/mario.c:            if (!(m->flags & MARIO_CAPS)) {
src/game/mario.c:                m->flags &= ~MARIO_CAP_ON_HEAD;
src/game/mario.c:        if (m->capTimer == 60) {
src/game/mario.c:        if ((m->capTimer < 64) && ((1ULL << m->capTimer) & sCapFlickerFrames)) {
src/game/mario.c:    struct MarioBodyState *bodyState = m->marioBodyState;
src/game/mario.c:    if ((m->invincTimer >= 3) && (gGlobalTimer & 1)) {
src/game/mario.c:    if (m->action & ACT_FLAG_SHORT_HITBOX) {
src/game/mario.c:        m->marioObj->hitboxHeight = 100.0f*GetMarioScaleFactors();
src/game/mario.c:        m->marioObj->hitboxHeight = 160.0f*GetMarioScaleFactors();
src/game/mario.c:    if ((m->flags & MARIO_TELEPORTING) && (m->fadeWarpOpacity != 0xFF)) {
src/game/mario.c:        bodyState->modelState |= (0x100 | m->fadeWarpOpacity);
src/game/mario.c:	m->Chaos_Vals[1] = m->Chaos_Vals[0];
src/game/mario.c:		m->Chaos_Vals[0] = newChaos;
src/game/mario.c:	}while(newChaos==m->Chaos_Vals[0]);
src/game/mario.c:		switch(m->Chaos_Vals[i]){
src/game/mario.c:				tempV = m->forwardVel;
src/game/mario.c:				// m->forwardVel = tempV;
src/game/mario.c:				tempV = m->forwardVel;
src/game/mario.c:				// m->forwardVel = tempV;
src/game/mario.c:				vec3f_set(m->marioObj->header.gfx.scale, 2.5f, 2.5f, 2.5f);
src/game/mario.c:				vec3f_set(m->marioObj->header.gfx.scale, 4.5f, 1.0f, 4.5f);
src/game/mario.c:				vec3f_set(m->marioObj->header.gfx.scale, 0.4f, 0.4f, 0.4f);
src/game/mario.c:				vec3f_set(m->marioObj->header.gfx.scale, 0.25f, 1.0f, 0.25f);
src/game/mario.c:				m->flags &= ~MARIO_CAP_ON_HEAD;
src/game/mario.c:				m->input |= INPUT_Z_DOWN;
src/game/mario.c:				m->flags |= 14;
src/game/mario.c:				m->capTimer=30;
src/game/mario.c:				if(m->forwardVel>0){
src/game/mario.c:					m->forwardVel+=32.0f;
src/game/mario.c:					m->forwardVel-=32.0f;
src/game/mario_actions_airborne.c:    s32 animFrame = m->marioObj->header.gfx.animInfo.animFrame;
src/game/mario_actions_airborne.c:        play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    u32 action = m->action;
src/game/mario_actions_airborne.c:        && !(m->flags & MARIO_UNKNOWN_18)) {
src/game/mario_actions_airborne.c:        if (m->peakHeight - m->pos[1] > 1150.0f) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:            m->flags |= MARIO_UNKNOWN_18;
src/game/mario_actions_airborne.c:    if (m->actionArg == 0 && (m->forwardVel <= -28.0f || m->forwardVel >= 28.0f)) {
src/game/mario_actions_airborne.c:    m->faceAngle[1] = atan2s(m->wall->normal.z, m->wall->normal.x);
src/game/mario_actions_airborne.c:    if (m->forwardVel < 24.0f) {
src/game/mario_actions_airborne.c:        m->forwardVel = 24.0f;
src/game/mario_actions_airborne.c:		if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_airborne.c:			m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 24 : 36;
src/game/mario_actions_airborne.c:		if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_airborne.c:			m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
src/game/mario_actions_airborne.c:    play_sound(SOUND_MARIO_ON_FIRE, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    fallHeight = m->peakHeight - m->pos[1];
src/game/mario_actions_airborne.c:	if (m->SelFallDmg){
src/game/mario_actions_airborne.c:		m->SelFallDmg=0;
src/game/mario_actions_airborne.c:    if (m->actionState == ACT_GROUND_POUND) {
src/game/mario_actions_airborne.c:    if (m->action != ACT_TWIRLING && m->floor->type != SURFACE_BURNING && FALL_DAMAGE) {
src/game/mario_actions_airborne.c:        if (m->vel[1] < -55.0f) {
src/game/mario_actions_airborne.c:                m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 16 : 24;
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 8 : 12;
src/game/mario_actions_airborne.c:                m->squishTimer = 30;
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:        return set_mario_action(m, m->forwardVel > 28.0f ? ACT_DIVE : ACT_JUMP_KICK, 0);
src/game/mario_actions_airborne.c:    u32 terrainType = m->area->terrainType & TERRAIN_MASK;
src/game/mario_actions_airborne.c:    struct Surface *floor = m->floor;
src/game/mario_actions_airborne.c:        if (!(flags & 0x01) && m->peakHeight - m->pos[1] > 1000.0f && floor->normal.y >= 0.8660254f) {
src/game/mario_actions_airborne.c:        play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        m->particleFlags |= PARTICLE_MIST_CIRCLE;
src/game/mario_actions_airborne.c:    floor = m->floor;
src/game/mario_actions_airborne.c:        m->slideVelX += 1.2f * sins(pushAngle);
src/game/mario_actions_airborne.c:        m->slideVelZ += 1.2f * coss(pushAngle);
src/game/mario_actions_airborne.c:        speed = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
src/game/mario_actions_airborne.c:            m->slideVelX = m->slideVelX * 48.0f / speed;
src/game/mario_actions_airborne.c:            m->slideVelZ = m->slideVelZ * 48.0f / speed;
src/game/mario_actions_airborne.c:        m->vel[0] = m->slideVelX;
src/game/mario_actions_airborne.c:        m->vel[2] = m->slideVelZ;
src/game/mario_actions_airborne.c:        m->slideYaw = atan2s(m->slideVelZ, m->slideVelX);
src/game/mario_actions_airborne.c:        m->forwardVel = speed * coss(m->faceAngle[1] - m->slideYaw);
src/game/mario_actions_airborne.c:        play_sound(SOUND_ENV_WIND2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        dragThreshold = m->action == ACT_LONG_JUMP ? 48.0f : 32.0f;
src/game/mario_actions_airborne.c:        m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.35f, 0.35f);
src/game/mario_actions_airborne.c:        if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_airborne.c:            intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_airborne.c:            intendedMag = m->intendedMag / 32.0f;
src/game/mario_actions_airborne.c:            m->forwardVel += 1.5f * coss(intendedDYaw) * intendedMag;
src/game/mario_actions_airborne.c:            m->faceAngle[1] += 512.0f * sins(intendedDYaw) * intendedMag;
src/game/mario_actions_airborne.c:        if (m->forwardVel > dragThreshold) {
src/game/mario_actions_airborne.c:            m->forwardVel -= 1.0f;
src/game/mario_actions_airborne.c:        if (m->forwardVel < -16.0f) {
src/game/mario_actions_airborne.c:            m->forwardVel += 2.0f;
src/game/mario_actions_airborne.c:        m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_airborne.c:        m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_airborne.c:        dragThreshold = m->action == ACT_LONG_JUMP ? 48.0f : 32.0f;
src/game/mario_actions_airborne.c:        m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.35f, 0.35f);
src/game/mario_actions_airborne.c:        if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_airborne.c:            intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_airborne.c:            intendedMag = m->intendedMag / 32.0f;
src/game/mario_actions_airborne.c:            m->forwardVel += intendedMag * coss(intendedDYaw) * 1.5f;
src/game/mario_actions_airborne.c:        if (m->forwardVel > dragThreshold) {
src/game/mario_actions_airborne.c:            m->forwardVel -= 1.0f;
src/game/mario_actions_airborne.c:        if (m->forwardVel < -16.0f) {
src/game/mario_actions_airborne.c:            m->forwardVel += 2.0f;
src/game/mario_actions_airborne.c:        m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_airborne.c:        m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_airborne.c:        m->slideVelX += sidewaysSpeed * sins(m->faceAngle[1] + 0x4000);
src/game/mario_actions_airborne.c:        m->slideVelZ += sidewaysSpeed * coss(m->faceAngle[1] + 0x4000);
src/game/mario_actions_airborne.c:        m->vel[0] = m->slideVelX;
src/game/mario_actions_airborne.c:        m->vel[2] = m->slideVelZ;
src/game/mario_actions_airborne.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_airborne.c:        intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_airborne.c:        intendedMag = m->intendedMag / 32.0f;
src/game/mario_actions_airborne.c:        m->forwardVel += coss(intendedDYaw) * intendedMag;
src/game/mario_actions_airborne.c:        m->faceAngle[1] += sins(intendedDYaw) * intendedMag * 1024.0f;
src/game/mario_actions_airborne.c:        if (m->forwardVel < 0.0f) {
src/game/mario_actions_airborne.c:            m->faceAngle[1] += 0x8000;
src/game/mario_actions_airborne.c:            m->forwardVel *= -1.0f;
src/game/mario_actions_airborne.c:        if (m->forwardVel > 32.0f) {
src/game/mario_actions_airborne.c:            m->forwardVel -= 2.0f;
src/game/mario_actions_airborne.c:    m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_airborne.c:    m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_airborne.c:    s16 targetYawVel = -(s16)(m->controller->stickX * (m->forwardVel / 4.0f));
src/game/mario_actions_airborne.c:        if (m->angleVel[1] < 0) {
src/game/mario_actions_airborne.c:            m->angleVel[1] += 0x40;
src/game/mario_actions_airborne.c:            if (m->angleVel[1] > 0x10) {
src/game/mario_actions_airborne.c:                m->angleVel[1] = 0x10;
src/game/mario_actions_airborne.c:            m->angleVel[1] = approach_s32(m->angleVel[1], targetYawVel, 0x10, 0x20);
src/game/mario_actions_airborne.c:        if (m->angleVel[1] > 0) {
src/game/mario_actions_airborne.c:            m->angleVel[1] -= 0x40;
src/game/mario_actions_airborne.c:            if (m->angleVel[1] < -0x10) {
src/game/mario_actions_airborne.c:                m->angleVel[1] = -0x10;
src/game/mario_actions_airborne.c:            m->angleVel[1] = approach_s32(m->angleVel[1], targetYawVel, 0x20, 0x10);
src/game/mario_actions_airborne.c:        m->angleVel[1] = approach_s32(m->angleVel[1], 0, 0x40, 0x40);
src/game/mario_actions_airborne.c:    m->faceAngle[1] += m->angleVel[1];
src/game/mario_actions_airborne.c:    m->faceAngle[2] = 20 * -m->angleVel[1];
src/game/mario_actions_airborne.c:    s16 targetPitchVel = -(s16)(m->controller->stickY * (m->forwardVel / 5.0f));
src/game/mario_actions_airborne.c:        if (m->angleVel[0] < 0) {
src/game/mario_actions_airborne.c:            m->angleVel[0] += 0x40;
src/game/mario_actions_airborne.c:            if (m->angleVel[0] > 0x20) {
src/game/mario_actions_airborne.c:                m->angleVel[0] = 0x20;
src/game/mario_actions_airborne.c:            m->angleVel[0] = approach_s32(m->angleVel[0], targetPitchVel, 0x20, 0x40);
src/game/mario_actions_airborne.c:        if (m->angleVel[0] > 0) {
src/game/mario_actions_airborne.c:            m->angleVel[0] -= 0x40;
src/game/mario_actions_airborne.c:            if (m->angleVel[0] < -0x20) {
src/game/mario_actions_airborne.c:                m->angleVel[0] = -0x20;
src/game/mario_actions_airborne.c:            m->angleVel[0] = approach_s32(m->angleVel[0], targetPitchVel, 0x40, 0x20);
src/game/mario_actions_airborne.c:        m->angleVel[0] = approach_s32(m->angleVel[0], 0, 0x40, 0x40);
src/game/mario_actions_airborne.c:    m->forwardVel -= 2.0f * ((f32) m->faceAngle[0] / 0x4000) + 0.1f;
src/game/mario_actions_airborne.c:    m->forwardVel -= 0.5f * (1.0f - coss(m->angleVel[1]));
src/game/mario_actions_airborne.c:    if (m->forwardVel < 0.0f) {
src/game/mario_actions_airborne.c:        m->forwardVel = 0.0f;
src/game/mario_actions_airborne.c:    if (m->forwardVel > 16.0f) {
src/game/mario_actions_airborne.c:        m->faceAngle[0] += (m->forwardVel - 32.0f) * 6.0f;
src/game/mario_actions_airborne.c:    } else if (m->forwardVel > 4.0f) {
src/game/mario_actions_airborne.c:        m->faceAngle[0] += (m->forwardVel - 32.0f) * 10.0f;
src/game/mario_actions_airborne.c:        m->faceAngle[0] -= 0x400;
src/game/mario_actions_airborne.c:    m->faceAngle[0] += m->angleVel[0];
src/game/mario_actions_airborne.c:    if (m->faceAngle[0] > 0x2AAA) {
src/game/mario_actions_airborne.c:        m->faceAngle[0] = 0x2AAA;
src/game/mario_actions_airborne.c:    if (m->faceAngle[0] < -0x2AAA) {
src/game/mario_actions_airborne.c:        m->faceAngle[0] = -0x2AAA;
src/game/mario_actions_airborne.c:    m->vel[0] = m->forwardVel * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
src/game/mario_actions_airborne.c:    m->vel[1] = m->forwardVel * sins(m->faceAngle[0]);
src/game/mario_actions_airborne.c:    m->vel[2] = m->forwardVel * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
src/game/mario_actions_airborne.c:    m->slideVelX = m->vel[0];
src/game/mario_actions_airborne.c:    m->slideVelZ = m->vel[2];
src/game/mario_actions_airborne.c:	if ((m->framesSinceA == 0) && (Super_Jump_Count<2) && (Super_Can_Jump>1)){
src/game/mario_actions_airborne.c:		m->vel[1]=45.0f;
src/game/mario_actions_airborne.c:			m->action = ACT_TRIPLE_JUMP;
src/game/mario_actions_airborne.c:			m->action = ACT_SPECIAL_TRIPLE_JUMP;
src/game/mario_actions_airborne.c:	}else if (m->framesSinceA > 0){
src/game/mario_actions_airborne.c:            if (m->forwardVel > 16.0f) {
src/game/mario_actions_airborne.c:                m->faceAngle[1] += 0x8000;
src/game/mario_actions_airborne.c:                if (m->wall != NULL) {
src/game/mario_actions_airborne.c:                    if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                        m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:                    if (m->forwardVel >= 38.0f) {
src/game/mario_actions_airborne.c:                        m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:                        if (m->forwardVel > 8.0f) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    s32 animation = (m->vel[1] >= 0.0f)
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->action == ACT_TRIPLE_JUMP_LAND) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->action == ACT_BACKFLIP_LAND) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    switch (m->actionArg) {
src/game/mario_actions_airborne.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_airborne.c:    if ((m->input & INPUT_B_PRESSED) && !(m->heldObj->oInteractionSubtype & INT_SUBTYPE_HOLDABLE_NPC)) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->actionArg == 0) {
src/game/mario_actions_airborne.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_airborne.c:    if ((m->input & INPUT_B_PRESSED) && !(m->heldObj->oInteractionSubtype & INT_SUBTYPE_HOLDABLE_NPC)) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:        m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_airborne.c:    if (m->marioObj->header.gfx.animInfo.animFrame == 6) play_sound(SOUND_ACTION_SIDE_FLIP_UNK, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (!m->marioObj->oMarioLongJumpIsSlow) {
src/game/mario_actions_airborne.c:    if (m->floor->type == SURFACE_VERTICAL_WIND && m->actionState == 0) {
src/game/mario_actions_airborne.c:        play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        m->actionState = 1;
src/game/mario_actions_airborne.c:    if (m->action == ACT_LONG_JUMP_LAND) {
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.pos[1] += 42.0f;
src/game/mario_actions_airborne.c:    s16 startTwirlYaw = m->twirlYaw;
src/game/mario_actions_airborne.c:    if (m->input & INPUT_A_DOWN) {
src/game/mario_actions_airborne.c:    m->angleVel[1] = approach_s32(m->angleVel[1], yawVelTarget, 0x200, 0x200);
src/game/mario_actions_airborne.c:    m->twirlYaw += m->angleVel[1];
src/game/mario_actions_airborne.c:    set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_START_TWIRL : MARIO_ANIM_TWIRL);
src/game/mario_actions_airborne.c:        m->actionArg = 1;
src/game/mario_actions_airborne.c:    if (startTwirlYaw > m->twirlYaw) {
src/game/mario_actions_airborne.c:        play_sound(SOUND_ACTION_TWIRL, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.angle[1] += m->twirlYaw;
src/game/mario_actions_airborne.c:    if (m->actionArg == 0) {
src/game/mario_actions_airborne.c:        m->marioBodyState->grabPos = GRAB_POS_LIGHT_OBJ;
src/game/mario_actions_airborne.c:        if (m->action != ACT_DIVE) {
src/game/mario_actions_airborne.c:            if (m->vel[1] < 0.0f && m->faceAngle[0] > -0x2AAA) {
src/game/mario_actions_airborne.c:                m->faceAngle[0] -= 0x200;
src/game/mario_actions_airborne.c:                if (m->faceAngle[0] < -0x2AAA) {
src/game/mario_actions_airborne.c:                    m->faceAngle[0] = -0x2AAA;
src/game/mario_actions_airborne.c:            m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
src/game/mario_actions_airborne.c:            if (should_get_stuck_in_ground(m) && m->faceAngle[0] == -0x2AAA) {
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                m->particleFlags |= PARTICLE_MIST_CIRCLE;
src/game/mario_actions_airborne.c:                if (m->heldObj == NULL) {
src/game/mario_actions_airborne.c:            m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:            m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:    if (++(m->actionTimer) == 4) {
src/game/mario_actions_airborne.c:                m->action = ACT_AIR_THROW_LAND;
src/game/mario_actions_airborne.c:    if (m->forwardVel < 15.0f) {
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_airborne.c:    if (m->forwardVel < 15.0f) {
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    mario_set_forward_vel(m, 0.98f * m->forwardVel);
src/game/mario_actions_airborne.c:                m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:                set_mario_action(m, m->forwardVel < 0.0f ? ACT_BEGIN_SLIDING : ACT_JUMP_LAND, 0);
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.angle[1] = m->marioObj->oMarioSteepJumpYaw;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        if (m->actionTimer < 10) {
src/game/mario_actions_airborne.c:            yOffset = 20 - 2 * m->actionTimer;
src/game/mario_actions_airborne.c:            if (m->pos[1] + yOffset + 160.0f < m->ceilHeight) {
src/game/mario_actions_airborne.c:                m->pos[1] += yOffset;
src/game/mario_actions_airborne.c:                m->peakHeight = m->pos[1];
src/game/mario_actions_airborne.c:                vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_airborne.c:        m->vel[1] = -50.0f;
src/game/mario_actions_airborne.c:        set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_START_GROUND_POUND
src/game/mario_actions_airborne.c:        if (m->actionTimer == 0) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        m->actionTimer++;
src/game/mario_actions_airborne.c:        if (m->actionTimer >= m->marioObj->header.gfx.animInfo.curAnim->loopEnd + 4) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_MARIO_GROUND_POUND_WAH, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                m->particleFlags |= PARTICLE_MIST_CIRCLE;
src/game/mario_actions_airborne.c:                    m->particleFlags |= PARTICLE_MIST_CIRCLE | PARTICLE_HORIZONTAL_STAR;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:    play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, m->actionArg == 0 ? 0 : -1);
src/game/mario_actions_airborne.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_airborne.c:    set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_SINGLE_JUMP : MARIO_ANIM_FIRE_LAVA_BURN);
src/game/mario_actions_airborne.c:    m->particleFlags |= PARTICLE_FIRE;
src/game/mario_actions_airborne.c:    play_sound(SOUND_MOVING_LAVA_BURN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    m->marioObj->oMarioBurnTimer += 3;
src/game/mario_actions_airborne.c:    m->health -= 10;
src/game/mario_actions_airborne.c:    if (m->health < 0x100) {
src/game/mario_actions_airborne.c:        m->health = 0xFF;
src/game/mario_actions_airborne.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_airborne.c:    m->particleFlags |= PARTICLE_FIRE;
src/game/mario_actions_airborne.c:    m->marioObj->oMarioBurnTimer += 3;
src/game/mario_actions_airborne.c:    m->health -= 10;
src/game/mario_actions_airborne.c:    if (m->health < 0x100) {
src/game/mario_actions_airborne.c:        m->health = 0xFF;
src/game/mario_actions_airborne.c:    if (m->actionTimer == 0) {
src/game/mario_actions_airborne.c:        switch (m->actionArg) {
src/game/mario_actions_airborne.c:                m->vel[1] = 45.0f;
src/game/mario_actions_airborne.c:                m->vel[1] = 60.0f;
src/game/mario_actions_airborne.c:                m->vel[1] = 100.0f;
src/game/mario_actions_airborne.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        if (m->forwardVel < minSpeed) {
src/game/mario_actions_airborne.c:        m->actionTimer = 1;
src/game/mario_actions_airborne.c:            if (m->actionArg < 2) {
src/game/mario_actions_airborne.c:                set_mario_action(m, ACT_CRAZY_BOX_BOUNCE, m->actionArg + 1);
src/game/mario_actions_airborne.c:                m->heldObj->oInteractStatus = INT_STATUS_STOP_RIDING;
src/game/mario_actions_airborne.c:                m->heldObj = NULL;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_MIST_CIRCLE;
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.angle[0] = atan2s(m->forwardVel, -m->vel[1]);
src/game/mario_actions_airborne.c:            if (m->action != ACT_SOFT_BONK) {
src/game/mario_actions_airborne.c:                if (m->action == ACT_THROWN_FORWARD || m->action == ACT_THROWN_BACKWARD) {
src/game/mario_actions_airborne.c:                    set_mario_action(m, landAction, m->hurtCounter);
src/game/mario_actions_airborne.c:                    set_mario_action(m, landAction, m->actionArg);
src/game/mario_actions_airborne.c:                set_mario_action(m, landAction, m->actionArg);
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:    if ((m->framesSinceA < 2) && m->wallKickTimer != 0 && m->prevAction == ACT_AIR_HIT_WALL && (m->framesSinceGround>m->framesSinceA)) {
src/game/mario_actions_airborne.c:        m->faceAngle[1] += 0x8000;
src/game/mario_actions_airborne.c:		m->wallKickTimer = 0;
src/game/mario_actions_airborne.c:    if (m->actionArg != 0) {
src/game/mario_actions_airborne.c:    common_air_knockback_step(m, landAction, ACT_HARD_BACKWARD_GROUND_KB, 0x0002, m->forwardVel);
src/game/mario_actions_airborne.c:    m->forwardVel *= 0.98f;
src/game/mario_actions_airborne.c:    if (m->actionArg != 0) {
src/game/mario_actions_airborne.c:    if (common_air_knockback_step(m, landAction, ACT_HARD_FORWARD_GROUND_KB, 0x002D, m->forwardVel)
src/game/mario_actions_airborne.c:        pitch = atan2s(m->forwardVel, -m->vel[1]);
src/game/mario_actions_airborne.c:        m->marioObj->header.gfx.angle[0] = pitch + 0x1800;
src/game/mario_actions_airborne.c:    m->forwardVel *= 0.98f;
src/game/mario_actions_airborne.c:    common_air_knockback_step(m, ACT_FREEFALL_LAND, ACT_HARD_BACKWARD_GROUND_KB, 0x0056, m->forwardVel);
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        if (m->forwardVel > -60.0f) {
src/game/mario_actions_airborne.c:            m->forwardVel -= 6.0f;
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:        if (m->forwardVel < -16.0f) {
src/game/mario_actions_airborne.c:            m->forwardVel += 0.8f;
src/game/mario_actions_airborne.c:        if (m->vel[1] < 0.0f && m->unkC4 < 4.0f) {
src/game/mario_actions_airborne.c:            m->unkC4 += 0.05f;
src/game/mario_actions_airborne.c:    if (++(m->actionTimer) == 20) {
src/game/mario_actions_airborne.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            mario_set_forward_vel(m, -m->forwardVel);
src/game/mario_actions_airborne.c:    if (m->heldObj != NULL) {
src/game/mario_actions_airborne.c:    if (++(m->actionTimer) <= 2) {
src/game/mario_actions_airborne.c:        if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_airborne.c:            m->vel[1] = 52.0f;
src/game/mario_actions_airborne.c:            m->faceAngle[1] += 0x8000;
src/game/mario_actions_airborne.c:    } else if (m->forwardVel >= 38.0f) {
src/game/mario_actions_airborne.c:        m->wallKickTimer = 5;
src/game/mario_actions_airborne.c:        if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:            m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:        m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:        m->wallKickTimer = 5;
src/game/mario_actions_airborne.c:        if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:            m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:        if (m->forwardVel > 8.0f) {
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        m->vel[1] = 30.0f;
src/game/mario_actions_airborne.c:        m->actionState = 1;
src/game/mario_actions_airborne.c:            if (m->actionState == 1) {
src/game/mario_actions_airborne.c:                    play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->actionState == 1 && is_anim_past_end(m)) {
src/game/mario_actions_airborne.c:        m->actionState = 2;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        m->vel[1] = 30.0f;
src/game/mario_actions_airborne.c:        m->actionState = 1;
src/game/mario_actions_airborne.c:            if (m->actionState == 1) {
src/game/mario_actions_airborne.c:                    play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->actionState == 1 && m->marioObj->header.gfx.animInfo.animFrame == 2) {
src/game/mario_actions_airborne.c:        m->actionState = 2;
src/game/mario_actions_airborne.c:    if (++(m->actionTimer) > 30 && m->pos[1] - m->floorHeight > 500.0f) {
src/game/mario_actions_airborne.c:            if (m->actionState == 0 && m->vel[1] < 0.0f && m->floor->normal.y >= 0.9848077f) {
src/game/mario_actions_airborne.c:                m->vel[1] = -m->vel[1] / 2.0f;
src/game/mario_actions_airborne.c:                m->actionState = 1;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_airborne.c:    if (++m->actionTimer > 30 && m->pos[1] - m->floorHeight > 500.0f) {
src/game/mario_actions_airborne.c:            if (m->actionState == 0 && m->vel[1] < 0.0f && m->floor->normal.y >= 0.9848077f) {
src/game/mario_actions_airborne.c:                m->vel[1] = -m->vel[1] / 2.0f;
src/game/mario_actions_airborne.c:                m->actionState = 1;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:    if (!(m->flags & MARIO_MARIO_SOUND_PLAYED)) {
src/game/mario_actions_airborne.c:    if (!(m->input & INPUT_NONZERO_ANALOG)) {
src/game/mario_actions_airborne.c:        m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.35f, 0.35f);
src/game/mario_actions_airborne.c:            if (m->floor->type == SURFACE_BURNING) {
src/game/mario_actions_airborne.c:                m->actionState = 0;
src/game/mario_actions_airborne.c:                if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_airborne.c:                    m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
src/game/mario_actions_airborne.c:                m->vel[1] = 84.0f;
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_ON_FIRE, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                if (m->actionState < 2 && m->vel[1] < 0.0f) {
src/game/mario_actions_airborne.c:                    m->vel[1] = -m->vel[1] * 0.4f;
src/game/mario_actions_airborne.c:                    mario_set_forward_vel(m, m->forwardVel * 0.5f);
src/game/mario_actions_airborne.c:                    m->actionState += 1;
src/game/mario_actions_airborne.c:    if ((m->area->terrainType & TERRAIN_MASK) != TERRAIN_SNOW && !(m->flags & MARIO_METAL_CAP)
src/game/mario_actions_airborne.c:        && m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:        m->particleFlags |= PARTICLE_FIRE;
src/game/mario_actions_airborne.c:        if (m->actionState == 0) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_MOVING_LAVA_BURN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->health < 0x100) {
src/game/mario_actions_airborne.c:    m->marioBodyState->eyeState = MARIO_EYES_DEAD;
src/game/mario_actions_airborne.c:    if (m->actionState == 0 && m->actionTimer == 0) {
src/game/mario_actions_airborne.c:    if (++(m->actionTimer) > 30 && m->pos[1] - m->floorHeight > 500.0f) {
src/game/mario_actions_airborne.c:            if (m->actionState == 0) {
src/game/mario_actions_airborne.c:                m->marioObj->header.gfx.angle[0] = atan2s(m->forwardVel, -m->vel[1]);
src/game/mario_actions_airborne.c:                if (m->marioObj->header.gfx.angle[0] > 0x1800) {
src/game/mario_actions_airborne.c:                    m->marioObj->header.gfx.angle[0] = 0x1800;
src/game/mario_actions_airborne.c:            if (m->actionState == 0 && m->vel[1] < 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = -m->vel[1] / 2.0f;
src/game/mario_actions_airborne.c:                m->actionState = 1;
src/game/mario_actions_airborne.c:                m->actionTimer = 0;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        m->marioObj->header.gfx.animInfo.animID = -1;
src/game/mario_actions_airborne.c:        m->actionState = 1;
src/game/mario_actions_airborne.c:    animFrame = m->marioObj->header.gfx.animInfo.animFrame;
src/game/mario_actions_airborne.c:        m->marioBodyState->punchState = (2 << 6) | 6;
src/game/mario_actions_airborne.c:        m->flags |= MARIO_KICKING;
src/game/mario_actions_airborne.c:    if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:        m->statusForCamera->cameraEvent = CAM_EVENT_SHOT_FROM_CANNON;
src/game/mario_actions_airborne.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_airborne.c:            m->faceAngle[0] = atan2s(m->forwardVel, m->vel[1]);
src/game/mario_actions_airborne.c:            m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
src/game/mario_actions_airborne.c:            m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAMERA_MODE_NEWCAM;
src/game/mario_actions_airborne.c:            m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAMERA_MODE_NEWCAM;
src/game/mario_actions_airborne.c:    if ((m->flags & MARIO_WING_CAP) && m->vel[1] < 0.0f) {
src/game/mario_actions_airborne.c:    if ((m->forwardVel -= 0.05) < 10.0f) {
src/game/mario_actions_airborne.c:    if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_airborne.c:    s16 startPitch = m->faceAngle[0];
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:        if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAMERA_MODE_NEWCAM;
src/game/mario_actions_airborne.c:    if (!(m->flags & MARIO_WING_CAP)) {
src/game/mario_actions_airborne.c:        if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAMERA_MODE_NEWCAM;
src/game/mario_actions_airborne.c:    if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:        set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:            m->area->camera->mode = CAMERA_MODE_NEWCAM;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        if (m->actionArg == 0) {
src/game/mario_actions_airborne.c:            if (m->marioObj->header.gfx.animInfo.animFrame == 1) {
src/game/mario_actions_airborne.c:                play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:            if (m->actionArg == 2) {
src/game/mario_actions_airborne.c:                m->actionArg = 1;
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:            m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
src/game/mario_actions_airborne.c:            m->marioObj->header.gfx.angle[2] = m->faceAngle[2];
src/game/mario_actions_airborne.c:            m->actionTimer = 0;
src/game/mario_actions_airborne.c:            m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAMERA_MODE_NEWCAM;
src/game/mario_actions_airborne.c:            if (m->wall != NULL) {
src/game/mario_actions_airborne.c:                m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:                if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                    m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:                play_sound((m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_BONK
src/game/mario_actions_airborne.c:                           m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAMERA_MODE_NEWCAM;
src/game/mario_actions_airborne.c:                if (m->actionTimer++ == 0) {
src/game/mario_actions_airborne.c:                    play_sound(SOUND_ACTION_HIT, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                if (m->actionTimer == 30) {
src/game/mario_actions_airborne.c:                    m->actionTimer = 0;
src/game/mario_actions_airborne.c:                m->faceAngle[0] -= 0x200;
src/game/mario_actions_airborne.c:                if (m->faceAngle[0] < -0x2AAA) {
src/game/mario_actions_airborne.c:                    m->faceAngle[0] = -0x2AAA;
src/game/mario_actions_airborne.c:                m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
src/game/mario_actions_airborne.c:                m->marioObj->header.gfx.angle[2] = m->faceAngle[2];
src/game/mario_actions_airborne.c:    if (m->faceAngle[0] > 0x800 && m->forwardVel >= 48.0f) {
src/game/mario_actions_airborne.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_airborne.c:    if (startPitch <= 0 && m->faceAngle[0] > 0 && m->forwardVel >= 48.0f) {
src/game/mario_actions_airborne.c:        play_sound(SOUND_ACTION_FLYING_FAST, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    play_sound(SOUND_MOVING_FLYING, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (!(m->input & INPUT_A_DOWN) || (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK7)) {
src/game/mario_actions_airborne.c:        m->usedObj->oInteractStatus = 0;
src/game/mario_actions_airborne.c:        m->usedObj->oHootMarioReleaseTime = gGlobalTimer;
src/game/mario_actions_airborne.c:    m->pos[0] = m->usedObj->oPosX;
src/game/mario_actions_airborne.c:    m->pos[1] = m->usedObj->oPosY - 92.5f;
src/game/mario_actions_airborne.c:    m->pos[2] = m->usedObj->oPosZ;
src/game/mario_actions_airborne.c:    m->faceAngle[1] = 0x4000 - m->usedObj->oMoveAngleYaw;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:    vec3f_set(m->vel, 0.0f, 0.0f, 0.0f);
src/game/mario_actions_airborne.c:    vec3f_set(m->marioObj->header.gfx.pos, m->pos[0], m->pos[1], m->pos[2]);
src/game/mario_actions_airborne.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, 0x4000 - m->faceAngle[1], 0);
src/game/mario_actions_airborne.c:    if (m->input & (INPUT_B_PRESSED | INPUT_Z_PRESSED)) {
src/game/mario_actions_airborne.c:        if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAMERA_MODE_NEWCAM;
src/game/mario_actions_airborne.c:        if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        if (m->marioObj->header.gfx.animInfo.animFrame == 7) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:    if (m->actionState == 1 && m->marioObj->header.gfx.animInfo.animFrame == 1) {
src/game/mario_actions_airborne.c:        play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->vel[1] < 4.0f) {
src/game/mario_actions_airborne.c:        if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAMERA_MODE_NEWCAM;
src/game/mario_actions_airborne.c:        if (m->forwardVel < 32.0f) {
src/game/mario_actions_airborne.c:    if (m->actionTimer++ == 10 && m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:        set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
src/game/mario_actions_airborne.c:    s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_airborne.c:    f32 intendedMag = m->intendedMag / 32.0f;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        if (m->marioObj->header.gfx.animInfo.animFrame == 1) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.angle[0] = (s16)(6144.0f * intendedMag * coss(intendedDYaw));
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.angle[2] = (s16)(-4096.0f * intendedMag * sins(intendedDYaw));
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:            if (m->actionState++ == 0) {
src/game/mario_actions_airborne.c:                m->vel[1] = 42.0f;
src/game/mario_actions_airborne.c:    if (m->actionState == 0 || m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_airborne.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_SQUISHED) {
src/game/mario_actions_airborne.c:    if (m->floor->type == SURFACE_VERTICAL_WIND && (m->action & ACT_FLAG_ALLOW_VERTICAL_WIND_ACTION)) {
src/game/mario_actions_airborne.c:    m->quicksandDepth = 0.0f;
src/game/mario_actions_airborne.c:    magnitude = sqrtf((m->controller->stickX*m->controller->stickX + m->controller->stickY*m->controller->stickY)); 
src/game/mario_actions_airborne.c:    x = magnitude * sins(m->intendedYaw); 
src/game/mario_actions_airborne.c:    z = magnitude * coss(m->intendedYaw);
src/game/mario_actions_airborne.c:    m->pos[0]+=m->platformDisplacement[0];
src/game/mario_actions_airborne.c:    m->vel[1]+=m->platformDisplacement[1];
src/game/mario_actions_airborne.c:    m->platformDisplacement[1] = 0;
src/game/mario_actions_airborne.c:    m->pos[2]+=m->platformDisplacement[2];
src/game/mario_actions_airborne.c:    if (absf2(m->platformDisplacement[0]+ x) < absf2(m->platformDisplacement[0])){
src/game/mario_actions_airborne.c:        m->platformDisplacement[0]+=x;
src/game/mario_actions_airborne.c:    if (absf2(m->platformDisplacement[2]+ z) < absf2(m->platformDisplacement[2])){
src/game/mario_actions_airborne.c:        m->platformDisplacement[2]+=z;
src/game/mario_actions_airborne.c:    switch (m->action) {
src/game/mario_actions_automatic.c:    if (m->usedObj->behavior == segmented_to_virtual(bhvTree)) {
src/game/mario_actions_automatic.c:        if (m->pos[1] - m->floorHeight > leafHeight) {
src/game/mario_actions_automatic.c:            m->particleFlags |= PARTICLE_LEAF;
src/game/mario_actions_automatic.c:    s32 isOnTree = (m->usedObj->behavior == segmented_to_virtual(bhvTree));
src/game/mario_actions_automatic.c:                       m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:    f32 poleTop = m->usedObj->hitboxHeight - 100.0f;
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    m->pos[0] = m->usedObj->oPosX;
src/game/mario_actions_automatic.c:    m->pos[2] = m->usedObj->oPosZ;
src/game/mario_actions_automatic.c:    m->pos[1] = m->usedObj->oPosY + marioObj->oMarioPolePos + offsetY;
src/game/mario_actions_automatic.c:    collided = f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 60.0f, 50.0f);
src/game/mario_actions_automatic.c:    collided |= f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 30.0f, 24.0f);
src/game/mario_actions_automatic.c:    ceilHeight = vec3f_find_ceil(m->pos, m->pos[1], &ceil);
src/game/mario_actions_automatic.c:    if (m->pos[1] > ceilHeight - 160.0f) {
src/game/mario_actions_automatic.c:        m->pos[1] = ceilHeight - 160.0f;
src/game/mario_actions_automatic.c:        marioObj->oMarioPolePos = m->pos[1] - m->usedObj->oPosY;
src/game/mario_actions_automatic.c:    floorHeight = find_floor(m->pos[0], m->pos[1], m->pos[2], &floor);
src/game/mario_actions_automatic.c:    if (m->pos[1] < floorHeight) {
src/game/mario_actions_automatic.c:        m->pos[1] = floorHeight;
src/game/mario_actions_automatic.c:    } else if (marioObj->oMarioPolePos < -m->usedObj->hitboxDownOffset) {
src/game/mario_actions_automatic.c:        m->pos[1] = m->usedObj->oPosY - m->usedObj->hitboxDownOffset;
src/game/mario_actions_automatic.c:        if (m->pos[1] > floorHeight + 20.0f) {
src/game/mario_actions_automatic.c:            m->forwardVel = -2.0f;
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    vec3s_set(m->marioObj->header.gfx.angle, m->usedObj->oMoveAnglePitch, m->faceAngle[1],
src/game/mario_actions_automatic.c:              m->usedObj->oMoveAngleRoll);
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_automatic.c:        m->faceAngle[1] += 0x8000;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_automatic.c:        m->forwardVel = -2.0f;
src/game/mario_actions_automatic.c:    if ((m->input & INPUT_Z_PRESSED) || m->health < 0x100) {
src/game/mario_actions_automatic.c:        m->forwardVel = -2.0f;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_automatic.c:        m->faceAngle[1] += 0x8000;
src/game/mario_actions_automatic.c:    if (m->controller->stickY > 16.0f) {
src/game/mario_actions_automatic.c:        f32 poleTop = m->usedObj->hitboxHeight - 100.0f;
src/game/mario_actions_automatic.c:        const BehaviorScript *poleBehavior = virtual_to_segmented(0x13, m->usedObj->behavior);
src/game/mario_actions_automatic.c:        if (poleBehavior != bhvGiantPole && m->controller->stickY > 50.0f) {
src/game/mario_actions_automatic.c:    if (m->controller->stickY < -16.0f) {
src/game/mario_actions_automatic.c:        marioObj->oMarioPoleYawVel -= m->controller->stickY * 2;
src/game/mario_actions_automatic.c:        m->faceAngle[1] += marioObj->oMarioPoleYawVel;
src/game/mario_actions_automatic.c:        if (m->usedObj->behavior == segmented_to_virtual(bhvTree)) {
src/game/mario_actions_automatic.c:            if (m->pos[1] - m->floorHeight > 100.0f) {
src/game/mario_actions_automatic.c:                m->particleFlags |= PARTICLE_LEAF;
src/game/mario_actions_automatic.c:        m->faceAngle[1] -= m->controller->stickX * 16.0f;
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    s16 cameraAngle = m->area->camera->yaw;
src/game/mario_actions_automatic.c:    if (m->health < 0x100) {
src/game/mario_actions_automatic.c:        m->forwardVel = -2.0f;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_automatic.c:        m->faceAngle[1] += 0x8000;
src/game/mario_actions_automatic.c:    if (m->controller->stickY < 8.0f) {
src/game/mario_actions_automatic.c:    marioObj->oMarioPolePos += m->controller->stickY / 8.0f;
src/game/mario_actions_automatic.c:    m->faceAngle[1] = cameraAngle - approach_s32((s16)(cameraAngle - m->faceAngle[1]), 0, 0x400, 0x400);
src/game/mario_actions_automatic.c:        sp24 = m->controller->stickY / 4.0f * 0x10000;
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    m->faceAngle[1] += marioObj->oMarioPoleYawVel;
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    if (m->actionArg == 0) {
src/game/mario_actions_automatic.c:        if (m->marioObj->header.gfx.animInfo.animFrame == 0) {
src/game/mario_actions_automatic.c:    UNUSED struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_automatic.c:    if (m->controller->stickY < -16.0f) {
src/game/mario_actions_automatic.c:    m->faceAngle[1] -= m->controller->stickX * 16.0f;
src/game/mario_actions_automatic.c:    m->wall = resolve_and_return_wall_collisions(nextPos, 50.0f, 50.0f);
src/game/mario_actions_automatic.c:    nextPos[1] = m->ceilHeight - 160.0f;
src/game/mario_actions_automatic.c:    vec3f_copy(m->pos, nextPos);
src/game/mario_actions_automatic.c:    m->floor = floor;
src/game/mario_actions_automatic.c:    m->floorHeight = floorHeight;
src/game/mario_actions_automatic.c:    m->ceil = ceil;
src/game/mario_actions_automatic.c:    m->ceilHeight = ceilHeight;
src/game/mario_actions_automatic.c:    m->forwardVel += 1.0f;
src/game/mario_actions_automatic.c:    if (m->forwardVel > maxSpeed) {
src/game/mario_actions_automatic.c:        m->forwardVel = maxSpeed;
src/game/mario_actions_automatic.c:    m->faceAngle[1] =
src/game/mario_actions_automatic.c:        m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
src/game/mario_actions_automatic.c:    m->slideYaw = m->faceAngle[1];
src/game/mario_actions_automatic.c:    m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->vel[0] = m->slideVelX;
src/game/mario_actions_automatic.c:    m->vel[1] = 0.0f;
src/game/mario_actions_automatic.c:    m->vel[2] = m->slideVelZ;
src/game/mario_actions_automatic.c:    nextPos[0] = m->pos[0] - m->ceil->normal.y * m->vel[0];
src/game/mario_actions_automatic.c:    nextPos[2] = m->pos[2] - m->ceil->normal.y * m->vel[2];
src/game/mario_actions_automatic.c:    nextPos[1] = m->pos[1];
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_automatic.c:    m->forwardVel = 0.0f;
src/game/mario_actions_automatic.c:    m->slideVelX = 0.0f;
src/game/mario_actions_automatic.c:    m->slideVelZ = 0.0f;
src/game/mario_actions_automatic.c:    m->pos[1] = m->ceilHeight - 160.0f;
src/game/mario_actions_automatic.c:    vec3f_copy(m->vel, gVec3fZero);
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    if (m->actionTimer++ == 0) {
src/game/mario_actions_automatic.c:    if ((m->input & INPUT_NONZERO_ANALOG) && m->actionTimer >= 31) {
src/game/mario_actions_automatic.c:    if (!(m->input & INPUT_A_DOWN)) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_automatic.c:    if (m->ceil->type != SURFACE_HANGABLE) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_automatic.c:        return set_mario_action(m, ACT_HANG_MOVING, m->actionArg);
src/game/mario_actions_automatic.c:    if (!(m->input & INPUT_A_DOWN)) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_automatic.c:    if (m->ceil->type != SURFACE_HANGABLE) {
src/game/mario_actions_automatic.c:    if (m->actionArg & 1) {
src/game/mario_actions_automatic.c:    if (!(m->input & INPUT_A_DOWN)) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_automatic.c:    if (m->ceil->type != SURFACE_HANGABLE) {
src/game/mario_actions_automatic.c:    if (m->actionArg & 1) {
src/game/mario_actions_automatic.c:    if (m->marioObj->header.gfx.animInfo.animFrame == 12) {
src/game/mario_actions_automatic.c:        play_sound(SOUND_ACTION_HANGING_STEP, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:        m->actionArg ^= 1;
src/game/mario_actions_automatic.c:        if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_automatic.c:            return set_mario_action(m, ACT_HANGING, m->actionArg);
src/game/mario_actions_automatic.c:    m->vel[1] = 0.0f;
src/game/mario_actions_automatic.c:    m->forwardVel = -8.0f;
src/game/mario_actions_automatic.c:    m->pos[0] -= 60.0f * sins(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->pos[2] -= 60.0f * coss(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    floorHeight = find_floor(m->pos[0], m->pos[1], m->pos[2], &floor);
src/game/mario_actions_automatic.c:    if (floorHeight < m->pos[1] - 100.0f) {
src/game/mario_actions_automatic.c:        m->pos[1] -= 100.0f;
src/game/mario_actions_automatic.c:        m->pos[1] = floorHeight;
src/game/mario_actions_automatic.c:    m->pos[0] += 14.0f * sins(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->pos[2] += 14.0f * coss(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    if (m->actionTimer < 14) {
src/game/mario_actions_automatic.c:        sp4 = m->actionTimer;
src/game/mario_actions_automatic.c:    m->statusForCamera->pos[0] = m->pos[0] + sp4 * sins(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->statusForCamera->pos[2] = m->pos[2] + sp4 * coss(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->statusForCamera->pos[1] = m->pos[1];
src/game/mario_actions_automatic.c:    m->actionTimer++;
src/game/mario_actions_automatic.c:    m->flags |= MARIO_UNKNOWN_25;
src/game/mario_actions_automatic.c:    s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_automatic.c:    s32 hasSpaceForMario = (m->ceilHeight - m->floorHeight >= 160.0f);
src/game/mario_actions_automatic.c:    if (m->actionTimer < 10) {
src/game/mario_actions_automatic.c:        m->actionTimer++;
src/game/mario_actions_automatic.c:    if (m->floor->normal.y < 0.9063078f) {
src/game/mario_actions_automatic.c:    if (m->input & (INPUT_Z_PRESSED | INPUT_OFF_FLOOR)) {
src/game/mario_actions_automatic.c:    if ((m->input & INPUT_A_PRESSED) && hasSpaceForMario) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_automatic.c:        if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK1) {
src/game/mario_actions_automatic.c:            m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
src/game/mario_actions_automatic.c:    if (m->actionTimer == 10 && (m->input & INPUT_NONZERO_ANALOG) && !(m->input & INPUT_A_DOWN))
src/game/mario_actions_automatic.c:    if (m->actionTimer == 10 && (m->input & INPUT_NONZERO_ANALOG))
src/game/mario_actions_automatic.c:    heightAboveFloor = m->pos[1] - find_floor_height_relative_polar(m, -0x8000, 30.0f);
src/game/mario_actions_automatic.c:    if (m->actionArg == 0) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_automatic.c:    if (m->actionTimer >= 28
src/game/mario_actions_automatic.c:        && (m->input
src/game/mario_actions_automatic.c:    if (m->actionTimer == 10) {
src/game/mario_actions_automatic.c:    if (m->marioObj->header.gfx.animInfo.animFrame == 17) {
src/game/mario_actions_automatic.c:        m->action = ACT_LEDGE_CLIMB_SLOW_2;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_automatic.c:    m->actionArg = 1;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_automatic.c:    if (m->marioObj->header.gfx.animInfo.animFrame == 8) {
src/game/mario_actions_automatic.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK2) {
src/game/mario_actions_automatic.c:        s32 thrown = (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK6) == 0;
src/game/mario_actions_automatic.c:        m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_automatic.c:        vec3f_copy(m->pos, m->marioObj->header.gfx.pos);
src/game/mario_actions_automatic.c:        return set_mario_action(m, (m->forwardVel >= 0.0f) ? ACT_THROWN_FORWARD : ACT_THROWN_BACKWARD,
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    s16 startFacePitch = m->faceAngle[0];
src/game/mario_actions_automatic.c:    s16 startFaceYaw = m->faceAngle[1];
src/game/mario_actions_automatic.c:    switch (m->actionState) {
src/game/mario_actions_automatic.c:            m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
src/game/mario_actions_automatic.c:            m->usedObj->oInteractStatus = INT_STATUS_INTERACTED;
src/game/mario_actions_automatic.c:            m->statusForCamera->cameraEvent = CAM_EVENT_CANNON;
src/game/mario_actions_automatic.c:            m->statusForCamera->usedObj = m->usedObj;
src/game/mario_actions_automatic.c:            vec3f_set(m->vel, 0.0f, 0.0f, 0.0f);
src/game/mario_actions_automatic.c:            m->pos[0] = m->usedObj->oPosX;
src/game/mario_actions_automatic.c:            m->pos[1] = m->usedObj->oPosY + 350.0f;
src/game/mario_actions_automatic.c:            m->pos[2] = m->usedObj->oPosZ;
src/game/mario_actions_automatic.c:            m->forwardVel = 0.0f;
src/game/mario_actions_automatic.c:            m->actionState = 1;
src/game/mario_actions_automatic.c:            if (m->usedObj->oAction == 1) {
src/game/mario_actions_automatic.c:                m->faceAngle[0] = m->usedObj->oMoveAnglePitch;
src/game/mario_actions_automatic.c:                m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_automatic.c:                marioObj->oMarioCannonObjectYaw = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_automatic.c:                m->actionState = 2;
src/game/mario_actions_automatic.c:            m->faceAngle[0] -= (s16)(m->controller->stickY * 10.0f);
src/game/mario_actions_automatic.c:            marioObj->oMarioCannonInputYaw -= (s16)(m->controller->stickX * 10.0f);
src/game/mario_actions_automatic.c:            if (m->faceAngle[0] > 0x38E3) {
src/game/mario_actions_automatic.c:                m->faceAngle[0] = 0x38E3;
src/game/mario_actions_automatic.c:            if (m->faceAngle[0] < 0) {
src/game/mario_actions_automatic.c:                m->faceAngle[0] = 0;
src/game/mario_actions_automatic.c:            m->faceAngle[1] = marioObj->oMarioCannonObjectYaw + marioObj->oMarioCannonInputYaw;
src/game/mario_actions_automatic.c:            if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_automatic.c:                m->forwardVel = 100.0f * coss(m->faceAngle[0]);
src/game/mario_actions_automatic.c:                m->vel[1] = 100.0f * sins(m->faceAngle[0]);
src/game/mario_actions_automatic.c:                m->pos[0] += 120.0f * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
src/game/mario_actions_automatic.c:                m->pos[1] += 120.0f * sins(m->faceAngle[0]);
src/game/mario_actions_automatic.c:                m->pos[2] += 120.0f * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
src/game/mario_actions_automatic.c:                play_sound(SOUND_ACTION_FLYING_FAST, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:                play_sound(SOUND_OBJ_POUNDING_CANNON, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:                m->marioObj->header.gfx.node.flags |= GRAPH_RENDER_ACTIVE;
src/game/mario_actions_automatic.c:                m->usedObj->oAction = 2;
src/game/mario_actions_automatic.c:            } else if (m->faceAngle[0] != startFacePitch || m->faceAngle[1] != startFaceYaw) {
src/game/mario_actions_automatic.c:                play_sound(SOUND_MOVING_AIM_CANNON, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    struct Object *usedObj = m->usedObj;
src/game/mario_actions_automatic.c:    s16 prevTwirlYaw = m->twirlYaw;
src/game/mario_actions_automatic.c:    f32 dx = (m->pos[0] - usedObj->oPosX) * 0.95f;
src/game/mario_actions_automatic.c:    f32 dz = (m->pos[2] - usedObj->oPosZ) * 0.95f;
src/game/mario_actions_automatic.c:    if (m->vel[1] < 60.0f) {
src/game/mario_actions_automatic.c:        m->vel[1] += 1.0f;
src/game/mario_actions_automatic.c:    if ((marioObj->oMarioTornadoPosY += m->vel[1]) < 0.0f) {
src/game/mario_actions_automatic.c:        if (m->vel[1] < 20.0f) {
src/game/mario_actions_automatic.c:            m->vel[1] = 20.0f;
src/game/mario_actions_automatic.c:    if (m->angleVel[1] < 0x3000) {
src/game/mario_actions_automatic.c:        m->angleVel[1] += 0x100;
src/game/mario_actions_automatic.c:    m->twirlYaw += m->angleVel[1];
src/game/mario_actions_automatic.c:        m->floor = floor;
src/game/mario_actions_automatic.c:        m->floorHeight = floorHeight;
src/game/mario_actions_automatic.c:        vec3f_copy(m->pos, nextPos);
src/game/mario_actions_automatic.c:        if (nextPos[1] >= m->floorHeight) {
src/game/mario_actions_automatic.c:            m->pos[1] = nextPos[1];
src/game/mario_actions_automatic.c:            m->pos[1] = m->floorHeight;
src/game/mario_actions_automatic.c:    m->actionTimer++;
src/game/mario_actions_automatic.c:    set_mario_animation(m, (m->actionArg == 0) ? MARIO_ANIM_START_TWIRL : MARIO_ANIM_TWIRL);
src/game/mario_actions_automatic.c:        m->actionArg = 1;
src/game/mario_actions_automatic.c:    if (prevTwirlYaw > m->twirlYaw) {
src/game/mario_actions_automatic.c:        play_sound(SOUND_ACTION_TWIRL, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1] + m->twirlYaw, 0);
src/game/mario_actions_automatic.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_automatic.c:    m->quicksandDepth = 0.0f;
src/game/mario_actions_automatic.c:    switch (m->action) {
src/game/mario_actions_cutscene.c:        if (m->prevNumStarsForDialog < numStarsRequired && m->numStars >= numStarsRequired) {
src/game/mario_actions_cutscene.c:    m->prevNumStarsForDialog = m->numStars;
src/game/mario_actions_cutscene.c:            m->faceAngle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    struct Object *o = spawn_object(m->marioObj, model, behavior);
src/game/mario_actions_cutscene.c:    o->oFaceAngleYaw = m->faceAngle[1] + relYaw;
src/game/mario_actions_cutscene.c:    o->oPosX = m->pos[0];
src/game/mario_actions_cutscene.c:    o->oPosY = m->pos[1];
src/game/mario_actions_cutscene.c:    o->oPosZ = m->pos[2];
src/game/mario_actions_cutscene.c:    m->flags &= ~MARIO_CAP_ON_HEAD;
src/game/mario_actions_cutscene.c:    m->flags |= MARIO_CAP_IN_HAND;
src/game/mario_actions_cutscene.c:    play_sound(SOUND_ACTION_UNKNOWN43D, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:    m->flags &= ~MARIO_CAP_IN_HAND;
src/game/mario_actions_cutscene.c:    m->flags |= MARIO_CAP_ON_HEAD;
src/game/mario_actions_cutscene.c:    play_sound(SOUND_ACTION_UNKNOWN43E, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:    if (m->actionArg == 2) {
src/game/mario_actions_cutscene.c:    if (m->actionArg == 3) {
src/game/mario_actions_cutscene.c:    if (m->actionState < 8) {
src/game/mario_actions_cutscene.c:        angleToNPC = mario_obj_angle_to_object(m, m->usedObj);
src/game/mario_actions_cutscene.c:        m->faceAngle[1] =
src/game/mario_actions_cutscene.c:            angleToNPC - approach_s32((angleToNPC - m->faceAngle[1]) << 16 >> 16, 0, 2048, 2048);
src/game/mario_actions_cutscene.c:        m->actionTimer += headTurnAmount;
src/game/mario_actions_cutscene.c:        set_mario_animation(m, m->heldObj == NULL ? MARIO_ANIM_FIRST_PERSON
src/game/mario_actions_cutscene.c:    } else if (m->actionState >= 9 && m->actionState < 17) {
src/game/mario_actions_cutscene.c:        m->actionTimer -= headTurnAmount;
src/game/mario_actions_cutscene.c:    } else if (m->actionState == 23) {
src/game/mario_actions_cutscene.c:        if (m->flags & MARIO_CAP_IN_HAND) {
src/game/mario_actions_cutscene.c:            set_mario_action(m, m->heldObj == NULL ? ACT_IDLE : ACT_HOLD_IDLE, 0);
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioBodyState->headAngle, m->actionTimer, 0, 0);
src/game/mario_actions_cutscene.c:    if (m->actionState != 8) {
src/game/mario_actions_cutscene.c:        m->actionState++;
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->heldObj == NULL ? MARIO_ANIM_FIRST_PERSON
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
src/game/mario_actions_cutscene.c:    if (m->actionArg) {
src/game/mario_actions_cutscene.c:        m->actionArg--;
src/game/mario_actions_cutscene.c:        if ((m->actionArg & 0xFFFF) == 0) {
src/game/mario_actions_cutscene.c:            level_trigger_warp(m, m->actionArg >> 16);
src/game/mario_actions_cutscene.c:    m->actionState++;
src/game/mario_actions_cutscene.c:    if (m->actionState == 2) {
src/game/mario_actions_cutscene.c:    if (m->actionState < 9) {
src/game/mario_actions_cutscene.c:        set_mario_animation(m, m->prevAction == ACT_STAR_DANCE_WATER ? MARIO_ANIM_WATER_IDLE
src/game/mario_actions_cutscene.c:        m->actionTimer -= 1024;
src/game/mario_actions_cutscene.c:        if (m->actionState == 9) {
src/game/mario_actions_cutscene.c:            actionArg = m->actionArg;
src/game/mario_actions_cutscene.c:        else if (m->actionState == 10) {
src/game/mario_actions_cutscene.c:                m->actionState--;
src/game/mario_actions_cutscene.c:        else if (m->actionState < 19) {
src/game/mario_actions_cutscene.c:            m->actionTimer += 1024;
src/game/mario_actions_cutscene.c:        else if (m->actionState == 25) {
src/game/mario_actions_cutscene.c:            if (m->prevAction == ACT_STAR_DANCE_WATER) {
src/game/mario_actions_cutscene.c:                set_mario_action(m, m->prevAction == ACT_UNLOCKING_STAR_DOOR ? ACT_WALKING : ACT_IDLE,
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioBodyState->headAngle, m->actionTimer, 0, 0);
src/game/mario_actions_cutscene.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:            m->actionState = 1;
src/game/mario_actions_cutscene.c:            m->faceAngle[1] += marioObj->oMarioPoleUnk108 / 11;
src/game/mario_actions_cutscene.c:            m->pos[0] += marioObj->oMarioReadingSignDPosX / 11.0f;
src/game/mario_actions_cutscene.c:            m->pos[2] += marioObj->oMarioReadingSignDPosZ / 11.0f;
src/game/mario_actions_cutscene.c:            if (m->actionTimer++ == 10) {
src/game/mario_actions_cutscene.c:                create_dialog_inverted_box(m->usedObj->oBehParams2ndByte);
src/game/mario_actions_cutscene.c:                m->actionState = 2;
src/game/mario_actions_cutscene.c:    vec3f_copy(marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:    vec3f_copy(pos, m->pos);
src/game/mario_actions_cutscene.c:    if (m->intendedMag > 0) {
src/game/mario_actions_cutscene.c:        pos[0] += 32.0f * speed * sins(m->intendedYaw);
src/game/mario_actions_cutscene.c:        pos[2] += 32.0f * speed * coss(m->intendedYaw);
src/game/mario_actions_cutscene.c:        vec3f_copy(m->pos, pos);
src/game/mario_actions_cutscene.c:    m->faceAngle[1] = m->intendedYaw;
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:        if (m->pos[1] <= m->waterLevel - 100) {
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        switch (++m->actionTimer) {
src/game/mario_actions_cutscene.c:                spawn_object(m->marioObj, MODEL_NONE, bhvCelebrationStar)->header.gfx.sharedChild = m->interactObj->header.gfx.sharedChild;
src/game/mario_actions_cutscene.c:                spawn_object(m->marioObj, MODEL_STAR, bhvCelebrationStar);
src/game/mario_actions_cutscene.c:                if (m->actionArg & 1) {
src/game/mario_actions_cutscene.c:                play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                if ((m->actionArg & 1) == 0) {
src/game/mario_actions_cutscene.c:                    m->actionState = 1;
src/game/mario_actions_cutscene.c:    } else if (m->actionState == 1 && gDialogResponse) {
src/game/mario_actions_cutscene.c:        m->actionState = 2;
src/game/mario_actions_cutscene.c:    } else if (m->actionState == 2 && is_anim_at_end(m)) {
src/game/mario_actions_cutscene.c:    m->faceAngle[1] = m->area->camera->yaw;
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->actionState == 2 ? MARIO_ANIM_RETURN_FROM_STAR_DANCE
src/game/mario_actions_cutscene.c:    if (m->actionState != 2 && m->actionTimer >= 40) {
src/game/mario_actions_cutscene.c:        m->marioBodyState->handState = MARIO_HAND_PEACE_SIGN;
src/game/mario_actions_cutscene.c:    m->faceAngle[1] = m->area->camera->yaw;
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->actionState == 2 ? MARIO_ANIM_RETURN_FROM_WATER_STAR_DANCE
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:    if (m->actionState != 2 && m->actionTimer >= 62) {
src/game/mario_actions_cutscene.c:        m->marioBodyState->handState = MARIO_HAND_PEACE_SIGN;
src/game/mario_actions_cutscene.c:    if (m->pos[1] < m->waterLevel - 130) {
src/game/mario_actions_cutscene.c:        play_sound(SOUND_ACTION_UNKNOWN430, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->particleFlags |= PARTICLE_WATER_SPLASH;
src/game/mario_actions_cutscene.c:        return set_mario_action(m, ACT_STAR_DANCE_WATER, m->actionArg);
src/game/mario_actions_cutscene.c:        set_mario_action(m, m->actionArg & 1 ? ACT_STAR_DANCE_NO_EXIT : ACT_STAR_DANCE_EXIT,
src/game/mario_actions_cutscene.c:                         m->actionArg);
src/game/mario_actions_cutscene.c:    m->marioBodyState->eyeState = MARIO_EYES_DEAD;
src/game/mario_actions_cutscene.c:    if (m->input & INPUT_IN_POISON_GAS) {
src/game/mario_actions_cutscene.c:    if (m->marioObj->header.gfx.animInfo.animFrame == 77) {
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    if (m->actionState == 1) {
src/game/mario_actions_cutscene.c:        if (m->quicksandDepth >= 100.0f) {
src/game/mario_actions_cutscene.c:        if ((m->quicksandDepth += 5.0f) >= 180.0f) {
src/game/mario_actions_cutscene.c:            m->actionState = 2;
src/game/mario_actions_cutscene.c:    play_sound(SOUND_MOVING_QUICKSAND_DEATH, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
src/game/mario_actions_cutscene.c:    m->health = 0xFF;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 60) {
src/game/mario_actions_cutscene.c:    m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_cutscene.c:    m->pos[0] = m->usedObj->oPosX + coss(m->faceAngle[1]) * 75.0f;
src/game/mario_actions_cutscene.c:    m->pos[2] = m->usedObj->oPosZ + sins(m->faceAngle[1]) * 75.0f;
src/game/mario_actions_cutscene.c:    if (m->actionArg & 2) {
src/game/mario_actions_cutscene.c:        m->faceAngle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 0) {
src/game/mario_actions_cutscene.c:    switch (m->marioObj->header.gfx.animInfo.animFrame) {
src/game/mario_actions_cutscene.c:            play_sound(SOUND_GENERAL_DOOR_INSERT_KEY, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:            play_sound(SOUND_GENERAL_DOOR_TURN_KEY, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        if (m->usedObj->oBehParams >> 24 == 1) {
src/game/mario_actions_cutscene.c:    m->actionTimer++;
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:            m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_cutscene.c:            if (m->actionArg & 2) {
src/game/mario_actions_cutscene.c:                m->faceAngle[1] += 0x8000;
src/game/mario_actions_cutscene.c:            m->marioObj->oMarioReadingSignDPosX = m->pos[0];
src/game/mario_actions_cutscene.c:            m->marioObj->oMarioReadingSignDPosZ = m->pos[2];
src/game/mario_actions_cutscene.c:            m->actionState++;
src/game/mario_actions_cutscene.c:                spawn_object(m->marioObj, MODEL_STAR, bhvUnlockDoorStar);
src/game/mario_actions_cutscene.c:                m->actionState++;
src/game/mario_actions_cutscene.c:            if (m->actionTimer++ == 70) {
src/game/mario_actions_cutscene.c:                m->actionState++;
src/game/mario_actions_cutscene.c:                save_file_set_flags(get_door_save_file_flag(m->usedObj));
src/game/mario_actions_cutscene.c:    m->pos[0] = m->marioObj->oMarioReadingSignDPosX;
src/game/mario_actions_cutscene.c:    m->pos[2] = m->marioObj->oMarioReadingSignDPosZ;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 0) {
src/game/mario_actions_cutscene.c:        m->interactObj->oInteractStatus = 0x00010000;
src/game/mario_actions_cutscene.c:        targetAngle = m->usedObj->oMoveAngleYaw + 0x1555;
src/game/mario_actions_cutscene.c:        if (m->actionArg & 2) {
src/game/mario_actions_cutscene.c:        targetDX = m->usedObj->oPosX + 150.0f * sins(targetAngle) - m->pos[0];
src/game/mario_actions_cutscene.c:        targetDZ = m->usedObj->oPosZ + 150.0f * coss(targetAngle) - m->pos[2];
src/game/mario_actions_cutscene.c:        m->marioObj->oMarioReadingSignDPosX = targetDX / 20.0f;
src/game/mario_actions_cutscene.c:        m->marioObj->oMarioReadingSignDPosZ = targetDZ / 20.0f;
src/game/mario_actions_cutscene.c:        m->faceAngle[1] = atan2s(targetDZ, targetDX);
src/game/mario_actions_cutscene.c:    if (m->actionTimer < 15) {
src/game/mario_actions_cutscene.c:    else if (m->actionTimer < 35) {
src/game/mario_actions_cutscene.c:        m->pos[0] += m->marioObj->oMarioReadingSignDPosX;
src/game/mario_actions_cutscene.c:        m->pos[2] += m->marioObj->oMarioReadingSignDPosZ;
src/game/mario_actions_cutscene.c:        m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_cutscene.c:        if (m->actionArg & 2) {
src/game/mario_actions_cutscene.c:            m->faceAngle[1] += 0x8000;
src/game/mario_actions_cutscene.c:        m->pos[0] += 12.0f * sins(m->faceAngle[1]);
src/game/mario_actions_cutscene.c:        m->pos[2] += 12.0f * coss(m->faceAngle[1]);
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 48) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 0) {
src/game/mario_actions_cutscene.c:        if (m->actionArg & 1) {
src/game/mario_actions_cutscene.c:            m->interactObj->oInteractStatus = 0x00010000;
src/game/mario_actions_cutscene.c:            m->interactObj->oInteractStatus = 0x00020000;
src/game/mario_actions_cutscene.c:    m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_cutscene.c:    m->pos[0] = m->usedObj->oPosX;
src/game/mario_actions_cutscene.c:    m->pos[2] = m->usedObj->oPosZ;
src/game/mario_actions_cutscene.c:    if (m->actionArg & 4) {
src/game/mario_actions_cutscene.c:        if (m->actionTimer == 16) {
src/game/mario_actions_cutscene.c:        if (m->actionArg & 2) {
src/game/mario_actions_cutscene.c:            m->faceAngle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    m->actionTimer++;
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:        if (m->actionArg & 1) {
src/game/mario_actions_cutscene.c:            m->usedObj->oInteractStatus = 0x00040000;
src/game/mario_actions_cutscene.c:            m->usedObj->oInteractStatus = 0x00080000;
src/game/mario_actions_cutscene.c:    } else if (m->usedObj->oAction == 0) {
src/game/mario_actions_cutscene.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ < 11) {
src/game/mario_actions_cutscene.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_cutscene.c:    // updates all velocity variables based on m->forwardVel
src/game/mario_actions_cutscene.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_cutscene.c:    if (m->actionState == 0 && m->pos[1] - m->floorHeight > 300.0f) {
src/game/mario_actions_cutscene.c:            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    if (15 < m->actionTimer++
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:            set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_GENERAL_LAND
src/game/mario_actions_cutscene.c:                m->actionState = 3; // star exit with cap
src/game/mario_actions_cutscene.c:                if (!(m->flags & MARIO_CAP_ON_HEAD)) {
src/game/mario_actions_cutscene.c:                    m->actionState = 2; // star exit without cap
src/game/mario_actions_cutscene.c:                    m->actionState = 1; // key exit
src/game/mario_actions_cutscene.c:                    play_sound(SOUND_ACTION_KEY_SWISH, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                    play_sound(SOUND_ACTION_PAT_BACK, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                    play_sound(SOUND_ACTION_UNKNOWN45C, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                m->marioBodyState->handState = MARIO_HAND_OPEN;
src/game/mario_actions_cutscene.c:                m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_cutscene.c:                    play_sound(SOUND_ACTION_BRUSH_HAIR, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    if (15 < m->actionTimer++
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->numLives--;
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->health = 0x0100;
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->numLives--;
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->health = 0x0100;
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->numLives--;
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->health = 0x0100;
src/game/mario_actions_cutscene.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ < 11) {
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:        m->actionArg = 1;
src/game/mario_actions_cutscene.c:    m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_cutscene.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ < 11) {
src/game/mario_actions_cutscene.c:        m->numLives--;
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->health = 0x0100;
src/game/mario_actions_cutscene.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_cutscene.c:    cageDX = m->usedObj->oPosX - m->pos[0];
src/game/mario_actions_cutscene.c:    cageDZ = m->usedObj->oPosZ - m->pos[2];
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:            floorDist = 512.0f - (m->pos[1] - m->floorHeight);
src/game/mario_actions_cutscene.c:            m->vel[1] = floorDist > 0 ? sqrtf(4.0f * floorDist + 1.0f) - 1.0f : 2.0f;
src/game/mario_actions_cutscene.c:            m->actionState = 1;
src/game/mario_actions_cutscene.c:            m->actionTimer = 100;
src/game/mario_actions_cutscene.c:            m->faceAngle[1] = atan2s(cageDZ, cageDX);
src/game/mario_actions_cutscene.c:                play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:            m->flags &= ~MARIO_UNKNOWN_08;
src/game/mario_actions_cutscene.c:            if (m->vel[1] <= 0) {
src/game/mario_actions_cutscene.c:                m->actionState = 2;
src/game/mario_actions_cutscene.c:            m->faceAngle[1] = atan2s(cageDZ, cageDX);
src/game/mario_actions_cutscene.c:            m->flags &= ~MARIO_UNKNOWN_08;
src/game/mario_actions_cutscene.c:                m->actionState = 4;
src/game/mario_actions_cutscene.c:            if (m->actionState == 2) {
src/game/mario_actions_cutscene.c:                if (m->marioObj->header.gfx.animInfo.animFrame == 0) {
src/game/mario_actions_cutscene.c:                    m->actionState = 3;
src/game/mario_actions_cutscene.c:                m->marioObj->header.gfx.angle[0] = atan2s(m->forwardVel, -m->vel[1]);
src/game/mario_actions_cutscene.c:            m->squishTimer = 0xFF;
src/game/mario_actions_cutscene.c:            if (m->actionTimer >= 11) {
src/game/mario_actions_cutscene.c:                m->actionTimer -= 6;
src/game/mario_actions_cutscene.c:                scale = m->actionTimer / 100.0f;
src/game/mario_actions_cutscene.c:                vec3f_set(m->marioObj->header.gfx.scale, scale, scale, scale);
src/game/mario_actions_cutscene.c:            m->marioObj->header.gfx.node.flags |= GRAPH_RENDER_INVISIBLE;
src/game/mario_actions_cutscene.c:        m, m->flags & MARIO_METAL_CAP ? SOUND_ACTION_METAL_JUMP : SOUND_ACTION_TERRAIN_JUMP, 1);
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        cageDX = m->usedObj->oPosX - m->pos[0];
src/game/mario_actions_cutscene.c:        cageDZ = m->usedObj->oPosZ - m->pos[2];
src/game/mario_actions_cutscene.c:        m->vel[1] = 60.0f;
src/game/mario_actions_cutscene.c:        m->faceAngle[1] = atan2s(cageDZ, cageDX);
src/game/mario_actions_cutscene.c:        m->flags &= ~MARIO_UNKNOWN_08;
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    if (m->vel[1] <= 0.0f) {
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->prevAction == ACT_CROUCHING ? MARIO_ANIM_CROUCHING
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 0) {
src/game/mario_actions_cutscene.c:    m->flags |= MARIO_TELEPORTING;
src/game/mario_actions_cutscene.c:    if (m->actionTimer < 32) {
src/game/mario_actions_cutscene.c:        m->fadeWarpOpacity = (-m->actionTimer << 3) + 0xF8;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 20) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 0) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer < 32) {
src/game/mario_actions_cutscene.c:        m->flags |= MARIO_TELEPORTING;
src/game/mario_actions_cutscene.c:        m->fadeWarpOpacity = m->actionTimer << 3;
src/game/mario_actions_cutscene.c:        m->flags &= ~MARIO_TELEPORTING;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 32) {
src/game/mario_actions_cutscene.c:        if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_cutscene.c:            if (m->area->camera->mode != CAMERA_MODE_WATER_SURFACE) {
src/game/mario_actions_cutscene.c:                set_camera_mode(m->area->camera, CAMERA_MODE_WATER_SURFACE, 1);
src/game/mario_actions_cutscene.c:    play_sound(SOUND_MOVING_SHOCKED, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->actionTimer++;
src/game/mario_actions_cutscene.c:        m->flags |= MARIO_METAL_SHOCK;
src/game/mario_actions_cutscene.c:    if (m->actionArg == 0) {
src/game/mario_actions_cutscene.c:            m->actionArg = 1;
src/game/mario_actions_cutscene.c:        if (m->actionTimer >= 6) {
src/game/mario_actions_cutscene.c:            m->invincTimer = 30;
src/game/mario_actions_cutscene.c:            set_mario_action(m, m->health < 0x0100 ? ACT_ELECTROCUTION : ACT_IDLE, 0);
src/game/mario_actions_cutscene.c:    if ((spaceUnderCeil = m->ceilHeight - m->floorHeight) < 0) {
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:                m->squishTimer = 0;
src/game/mario_actions_cutscene.c:            m->squishTimer = 0xFF;
src/game/mario_actions_cutscene.c:                vec3f_set(m->marioObj->header.gfx.scale, 2.0f - squishAmount, squishAmount,
src/game/mario_actions_cutscene.c:                if (!(m->flags & MARIO_METAL_CAP) && m->invincTimer == 0) {
src/game/mario_actions_cutscene.c:                    m->hurtCounter += m->flags & MARIO_CAP_ON_HEAD ? 12 : 18;
src/game/mario_actions_cutscene.c:                vec3f_set(m->marioObj->header.gfx.scale, 1.8, 0.05f, 1.8f);
src/game/mario_actions_cutscene.c:                m->actionState = 1;
src/game/mario_actions_cutscene.c:                m->actionState = 2;
src/game/mario_actions_cutscene.c:            m->actionTimer++;
src/game/mario_actions_cutscene.c:            if (m->actionTimer >= 15) {
src/game/mario_actions_cutscene.c:                if (m->health < 0x0100) {
src/game/mario_actions_cutscene.c:                } else if (m->hurtCounter == 0) {
src/game/mario_actions_cutscene.c:                    m->squishTimer = 30;
src/game/mario_actions_cutscene.c:    if (m->floor != NULL && m->floor->normal.y < 0.5f) {
src/game/mario_actions_cutscene.c:        surfAngle = atan2s(m->floor->normal.z, m->floor->normal.x);
src/game/mario_actions_cutscene.c:    if (m->ceil != NULL && -0.5f < m->ceil->normal.y) {
src/game/mario_actions_cutscene.c:        surfAngle = atan2s(m->ceil->normal.z, m->ceil->normal.x);
src/game/mario_actions_cutscene.c:        m->vel[0] = sins(surfAngle) * 10.0f;
src/game/mario_actions_cutscene.c:        m->vel[2] = coss(surfAngle) * 10.0f;
src/game/mario_actions_cutscene.c:        m->vel[1] = 0;
src/game/mario_actions_cutscene.c:            m->squishTimer = 0;
src/game/mario_actions_cutscene.c:    if (m->actionArg++ > 300) {
src/game/mario_actions_cutscene.c:        m->health = 0x00FF;
src/game/mario_actions_cutscene.c:        m->hurtCounter = 0;
src/game/mario_actions_cutscene.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_cutscene.c:        m->actionTimer++;
src/game/mario_actions_cutscene.c:        if (m->actionTimer >= 5 && animFrame < unstuckFrame - 1) {
src/game/mario_actions_cutscene.c:    m->actionState = 0;
src/game/mario_actions_cutscene.c:    m->actionTimer = 0;
src/game/mario_actions_cutscene.c:    m->actionArg++;
src/game/mario_actions_cutscene.c:    m->statusForCamera->cameraEvent = CAM_EVENT_START_INTRO;
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
src/game/mario_actions_cutscene.c:    if ((s16) m->statusForCamera->cameraEvent != CAM_EVENT_START_INTRO) {
src/game/mario_actions_cutscene.c:        if (m->actionTimer++ == TIMER_SPAWN_PIPE) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 0) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == TIMER_RAISE_PIPE) {
src/game/mario_actions_cutscene.c:        m->vel[1] = 60.0f;
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 25) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ >= 118) {
src/game/mario_actions_cutscene.c:        m->marioObj->header.gfx.node.flags |= GRAPH_RENDER_ACTIVE;
src/game/mario_actions_cutscene.c:            play_sound(SOUND_MARIO_HAHA, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 0) {
src/game/mario_actions_cutscene.c:    switch (m->actionArg) {
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        m->input |= INPUT_A_DOWN;
src/game/mario_actions_cutscene.c:        m->flags |= (MARIO_WING_CAP | MARIO_CAP_ON_HEAD);
src/game/mario_actions_cutscene.c:        m->faceAngle[1] = -0x8000;
src/game/mario_actions_cutscene.c:        m->pos[0] = 0.0f;
src/game/mario_actions_cutscene.c:        m->pos[2] = 0.0f;
src/game/mario_actions_cutscene.c:            m->actionState++;
src/game/mario_actions_cutscene.c:            m->statusForCamera->cameraEvent = CAM_EVENT_START_GRAND_STAR;
src/game/mario_actions_cutscene.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:            m->actionState++;
src/game/mario_actions_cutscene.c:                           m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                play_sound(SOUND_MARIO_HOOHOO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                play_sound(SOUND_MARIO_YAHOO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_cutscene.c:    vec3f_set(m->pos, 0.0f, 307.0, marioObj->rawData.asF32[0x22]);
src/game/mario_actions_cutscene.c:    vec3f_copy(marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:    UNUSED struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:            m->actionState++;
src/game/mario_actions_cutscene.c:                m->actionState++;
src/game/mario_actions_cutscene.c:                targetDX = targetPos[0] - m->pos[0];
src/game/mario_actions_cutscene.c:                targetDY = targetPos[1] - m->pos[1];
src/game/mario_actions_cutscene.c:                targetDZ = targetPos[2] - m->pos[2];
src/game/mario_actions_cutscene.c:                vec3f_copy(m->pos, targetPos);
src/game/mario_actions_cutscene.c:                m->marioObj->header.gfx.angle[0] = -atan2s(targetHyp, targetDY);
src/game/mario_actions_cutscene.c:                m->marioObj->header.gfx.angle[1] = targetAngle;
src/game/mario_actions_cutscene.c:                m->marioObj->header.gfx.angle[2] = ((m->faceAngle[1] - targetAngle) << 16 >> 16) * 20;
src/game/mario_actions_cutscene.c:                m->faceAngle[1] = targetAngle;
src/game/mario_actions_cutscene.c:    m->marioBodyState->handState = MARIO_HAND_RIGHT_OPEN;
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 1) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 500) {
src/game/mario_actions_cutscene.c:    switch (m->actionArg) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 1) {
src/game/mario_actions_cutscene.c:        m->statusForCamera->cameraEvent = CAM_EVENT_START_ENDING;
src/game/mario_actions_cutscene.c:    m->input |= INPUT_A_DOWN;
src/game/mario_actions_cutscene.c:    m->flags |= (MARIO_WING_CAP | MARIO_CAP_ON_HEAD);
src/game/mario_actions_cutscene.c:        m->capTimer = 60;
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->actionState == 0 ? MARIO_ANIM_CREDITS_RAISE_HAND
src/game/mario_actions_cutscene.c:    if (m->actionState == 0 && is_anim_past_end(m)) {
src/game/mario_actions_cutscene.c:        m->actionState++;
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 90) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 255) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 1) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 2) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 44) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 40) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= TIMER_FADE_IN_PEACH) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= 40) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == TIMER_DESCEND_PEACH) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= 40) {
src/game/mario_actions_cutscene.c:        if (m->actionState < 60) {
src/game/mario_actions_cutscene.c:            m->actionState += 5;
src/game/mario_actions_cutscene.c:        if (m->actionState >= 27) {
src/game/mario_actions_cutscene.c:            m->actionState -= 2;
src/game/mario_actions_cutscene.c:    if ((sEndPeachObj->oPosY -= m->actionState / 10) <= 907.0f) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= TIMER_RUN_TO_PEACH) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 22) {
src/game/mario_actions_cutscene.c:    if ((m->pos[2] -= 20.0f) <= -1181.0f) {
src/game/mario_actions_cutscene.c:        m->pos[2] = -1180.0f;
src/game/mario_actions_cutscene.c:    m->pos[1] = find_floor(m->pos[0], m->pos[1], m->pos[2], &surf);
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_cutscene.c:    s32 animFrame = set_mario_animation(m, m->actionState == 0 ? MARIO_ANIM_CREDITS_TAKE_OFF_CAP
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:            m->actionState++;
src/game/mario_actions_cutscene.c:    switch (m->actionTimer) {
src/game/mario_actions_cutscene.c:    switch (m->actionTimer) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= 90) {
src/game/mario_actions_cutscene.c:        m->marioBodyState->eyeState =
src/game/mario_actions_cutscene.c:            m->actionTimer < 110 ? sMarioBlinkOverride[m->actionTimer - 90] : MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_cutscene.c:    switch (m->actionTimer) {
src/game/mario_actions_cutscene.c:            m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_cutscene.c:            m->marioBodyState->eyeState = MARIO_EYES_CLOSED;
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->marioBodyState->handState = MARIO_HAND_PEACE_SIGN;
src/game/mario_actions_cutscene.c:    if (m->actionTimer < 52) {
src/game/mario_actions_cutscene.c:        m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_cutscene.c:    switch (m->actionTimer) {
src/game/mario_actions_cutscene.c:    switch (m->actionTimer) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 350) {
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->actionState == 0 ? MARIO_ANIM_CREDITS_START_WALK_LOOK_UP
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.pos[1] = end_obj_set_visual_pos(m->marioObj);
src/game/mario_actions_cutscene.c:    if (m->actionState == 0 && is_anim_past_end(m)) {
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 95) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 389) {
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    switch (m->actionArg) {
src/game/mario_actions_cutscene.c:    m->actionTimer++;
src/game/mario_actions_cutscene.c:    m->statusForCamera->cameraEvent = CAM_EVENT_START_CREDITS;
src/game/mario_actions_cutscene.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_cutscene.c:        if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_cutscene.c:            set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
src/game/mario_actions_cutscene.c:        vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:        vec3s_copy(m->marioObj->header.gfx.angle, m->faceAngle);
src/game/mario_actions_cutscene.c:        m->particleFlags |= PARTICLE_BUBBLE;
src/game/mario_actions_cutscene.c:        if (m->actionTimer > 0) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= TIMER_CREDITS_SHOW) {
src/game/mario_actions_cutscene.c:        if (m->actionState < 40) {
src/game/mario_actions_cutscene.c:            m->actionState += 2;
src/game/mario_actions_cutscene.c:        width = m->actionState * (SCREEN_WIDTH * 2) / 100;
src/game/mario_actions_cutscene.c:        height = m->actionState * (SCREEN_HEIGHT * 2) / 100;
src/game/mario_actions_cutscene.c:    if (m->actionTimer == TIMER_CREDITS_PROGRESS) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= TIMER_CREDITS_PROGRESS) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == TIMER_CREDITS_WARP) {
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        m->statusForCamera->cameraEvent = CAM_EVENT_START_END_WAVING;
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.pos[0] -= 60.0f;
src/game/mario_actions_cutscene.c:    m->marioBodyState->handState = MARIO_HAND_RIGHT_OPEN;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 300) {
src/game/mario_actions_cutscene.c:    if (m->floor->type == SURFACE_INSTANT_QUICKSAND && m->action & ACT_FLAG_INVULNERABLE
src/game/mario_actions_cutscene.c:        && m->action != ACT_QUICKSAND_DEATH) {
src/game/mario_actions_cutscene.c:    switch (m->action) {
src/game/mario_actions_cutscene.c:    if (!cancel && (m->input & INPUT_IN_WATER)) {
src/game/mario_actions_cutscene.c:        m->particleFlags |= PARTICLE_IDLE_WATER_WAVE;
src/game/mario_actions_moving.c:    pitch = pitch * m->forwardVel / 40.0f;
src/game/mario_actions_moving.c:        if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_moving.c:            if (m->marioObj->header.gfx.animInfo.animID == MARIO_ANIM_TIPTOE) {
src/game/mario_actions_moving.c:        } else if (m->quicksandDepth > 50.0f) {
src/game/mario_actions_moving.c:            play_sound(SOUND_ACTION_QUICKSAND_STEP, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:        } else if (m->marioObj->header.gfx.animInfo.animID == MARIO_ANIM_TIPTOE) {
src/game/mario_actions_moving.c:    m->pos[1] = m->floorHeight;
src/game/mario_actions_moving.c:    mtxf_align_terrain_triangle(sFloorAlignMatrix[m->unk00], m->pos, m->faceAngle[1], 40.0f);
src/game/mario_actions_moving.c:    m->marioObj->header.gfx.throwMatrix = &sFloorAlignMatrix[m->unk00];
src/game/mario_actions_moving.c:    m->faceAngle[1] = m->intendedYaw;
src/game/mario_actions_moving.c:    if (m->forwardVel < 10.0f) {
src/game/mario_actions_moving.c:        wallCols.x = m->pos[0];
src/game/mario_actions_moving.c:        wallCols.y = m->pos[1];
src/game/mario_actions_moving.c:        wallCols.z = m->pos[2];
src/game/mario_actions_moving.c:                wallDYaw = wallAngle - m->faceAngle[1];
src/game/mario_actions_moving.c:                    m->pos[0] = wallCols.x - 20.0f * wall->normal.x;
src/game/mario_actions_moving.c:                    m->pos[2] = wallCols.z - 20.0f * wall->normal.z;
src/game/mario_actions_moving.c:                    m->faceAngle[0] = 0;
src/game/mario_actions_moving.c:                    m->faceAngle[1] = wallAngle + 0x8000;
src/game/mario_actions_moving.c:    if (m->forwardVel > 16.0f) {
src/game/mario_actions_moving.c:    if (m->flags & MARIO_WING_CAP) {
src/game/mario_actions_moving.c:    } else if (m->forwardVel > 20.0f) {
src/game/mario_actions_moving.c:    struct Surface *floor = m->floor;
src/game/mario_actions_moving.c:    m->slideVelX += accel * steepness * sins(slopeAngle);
src/game/mario_actions_moving.c:    m->slideVelZ += accel * steepness * coss(slopeAngle);
src/game/mario_actions_moving.c:    m->slideVelX *= lossFactor;
src/game/mario_actions_moving.c:    m->slideVelZ *= lossFactor;
src/game/mario_actions_moving.c:    m->slideYaw = atan2s(m->slideVelZ, m->slideVelX);
src/game/mario_actions_moving.c:    facingDYaw = m->faceAngle[1] - m->slideYaw;
src/game/mario_actions_moving.c:    m->faceAngle[1] = m->slideYaw + newFacingDYaw;
src/game/mario_actions_moving.c:    m->vel[0] = m->slideVelX;
src/game/mario_actions_moving.c:    m->vel[1] = 0.0f;
src/game/mario_actions_moving.c:    m->vel[2] = m->slideVelZ;
src/game/mario_actions_moving.c:    m->forwardVel = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
src/game/mario_actions_moving.c:    if (m->forwardVel > 100.0f) {
src/game/mario_actions_moving.c:        m->slideVelX = m->slideVelX * 100.0f / m->forwardVel;
src/game/mario_actions_moving.c:        m->slideVelZ = m->slideVelZ * 100.0f / m->forwardVel;
src/game/mario_actions_moving.c:        m->forwardVel *= -1.0f;
src/game/mario_actions_moving.c:    s16 intendedDYaw = m->intendedYaw - m->slideYaw;
src/game/mario_actions_moving.c:    if (forward < 0.0f && m->forwardVel >= 0.0f) {
src/game/mario_actions_moving.c:        forward *= 0.5f + 0.5f * m->forwardVel / 100.0f;
src/game/mario_actions_moving.c:            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.98f;
src/game/mario_actions_moving.c:            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.96f;
src/game/mario_actions_moving.c:            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.92f;
src/game/mario_actions_moving.c:            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.92f;
src/game/mario_actions_moving.c:    oldSpeed = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
src/game/mario_actions_moving.c:    m->slideVelX += m->slideVelZ * (m->intendedMag / 32.0f) * sideward * 0.05f;
src/game/mario_actions_moving.c:    m->slideVelZ -= m->slideVelX * (m->intendedMag / 32.0f) * sideward * 0.05f;
src/game/mario_actions_moving.c:    newSpeed = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
src/game/mario_actions_moving.c:        m->slideVelX = m->slideVelX * oldSpeed / newSpeed;
src/game/mario_actions_moving.c:        m->slideVelZ = m->slideVelZ * oldSpeed / newSpeed;
src/game/mario_actions_moving.c:    if (!mario_floor_is_slope(m) && m->forwardVel * m->forwardVel < stopSpeed * stopSpeed) {
src/game/mario_actions_moving.c:    struct Surface *floor = m->floor;
src/game/mario_actions_moving.c:    s16 floorDYaw = m->floorAngle - m->faceAngle[1];
src/game/mario_actions_moving.c:        if (m->action != ACT_SOFT_BACKWARD_GROUND_KB && m->action != ACT_SOFT_FORWARD_GROUND_KB) {
src/game/mario_actions_moving.c:            m->forwardVel += slopeAccel * steepness;
src/game/mario_actions_moving.c:            m->forwardVel -= slopeAccel * steepness;
src/game/mario_actions_moving.c:    m->slideYaw = m->faceAngle[1];
src/game/mario_actions_moving.c:    m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_moving.c:    m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_moving.c:    m->vel[0] = m->slideVelX;
src/game/mario_actions_moving.c:    m->vel[1] = 0.0f;
src/game/mario_actions_moving.c:    m->vel[2] = m->slideVelZ;
src/game/mario_actions_moving.c:        m->forwardVel *= frictionFactor;
src/game/mario_actions_moving.c:        if (m->forwardVel * m->forwardVel < 1.0f) {
src/game/mario_actions_moving.c:    if (m->floorHeight < m->waterLevel) {
src/game/mario_actions_moving.c:        m->floorHeight = m->waterLevel;
src/game/mario_actions_moving.c:        m->floor = &gWaterSurfacePseudoFloor;
src/game/mario_actions_moving.c:        m->floor->originOffset = m->waterLevel; //! Negative origin offset
src/game/mario_actions_moving.c:    if (m->floor != NULL && m->floor->type == SURFACE_SLOW) {
src/game/mario_actions_moving.c:    targetSpeed = m->intendedMag * 2.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel <= 0.0f) {
src/game/mario_actions_moving.c:        m->forwardVel += 1.1f;
src/game/mario_actions_moving.c:    } else if (m->forwardVel <= targetSpeed) {
src/game/mario_actions_moving.c:        m->forwardVel += 1.1f - m->forwardVel / 58.0f;
src/game/mario_actions_moving.c:    } else if (m->floor->normal.y >= 0.95f) {
src/game/mario_actions_moving.c:        m->forwardVel -= 1.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel > 64.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 64.0f;
src/game/mario_actions_moving.c:    m->faceAngle[1] =
src/game/mario_actions_moving.c:        m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
src/game/mario_actions_moving.c:    if ((m->forwardVel = approach_f32(m->forwardVel, 0.0f, decel, decel)) == 0.0f) {
src/game/mario_actions_moving.c:    if ((m->forwardVel = approach_f32(m->forwardVel, 0.0f, 1.0f, 1.0f)) == 0.0f) {
src/game/mario_actions_moving.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_moving.c:		if (m->Chaos_Vals[0]==13 | m->Chaos_Vals[1]==13){
src/game/mario_actions_moving.c:			if (m->floor != NULL && m->floor->type == SURFACE_SLOW) {
src/game/mario_actions_moving.c:		}else if (m->Chaos_Vals[0]==12 | m->Chaos_Vals[1]==12){
src/game/mario_actions_moving.c:			m->intendedMag*=2;
src/game/mario_actions_moving.c:			m->forwardVel+=2;
src/game/mario_actions_moving.c:			if (m->floor != NULL && m->floor->type == SURFACE_SLOW) {
src/game/mario_actions_moving.c:			if (m->floor != NULL && m->floor->type == SURFACE_SLOW) {
src/game/mario_actions_moving.c:		if (m->floor != NULL && m->floor->type == SURFACE_SLOW) {
src/game/mario_actions_moving.c:    targetSpeed = m->intendedMag < maxTargetSpeed ? m->intendedMag : maxTargetSpeed;
src/game/mario_actions_moving.c:    if (m->quicksandDepth > 10.0f) {
src/game/mario_actions_moving.c:        targetSpeed *= 6.25 / m->quicksandDepth;
src/game/mario_actions_moving.c:    if (m->forwardVel <= 0.0f) {
src/game/mario_actions_moving.c:        m->forwardVel += 1.1f;
src/game/mario_actions_moving.c:    } else if (m->forwardVel <= targetSpeed) {
src/game/mario_actions_moving.c:        m->forwardVel += 1.1f - m->forwardVel / 43.0f;
src/game/mario_actions_moving.c:    } else if (m->floor->normal.y >= 0.95f) {
src/game/mario_actions_moving.c:        m->forwardVel -= 1.0f;
src/game/mario_actions_moving.c:		if (m->Chaos_Vals[0]==13 | m->Chaos_Vals[1]==13){
src/game/mario_actions_moving.c:			if (m->forwardVel > 24.0f) {
src/game/mario_actions_moving.c:				m->forwardVel = 24.0f;
src/game/mario_actions_moving.c:		}else if (m->Chaos_Vals[0]==12 | m->Chaos_Vals[1]==12){
src/game/mario_actions_moving.c:			if (m->forwardVel > 64.0f) {
src/game/mario_actions_moving.c:				m->forwardVel = 64.0f;
src/game/mario_actions_moving.c:			if (m->forwardVel > 48.0f) {
src/game/mario_actions_moving.c:				m->forwardVel = 48.0f;
src/game/mario_actions_moving.c:		if (m->forwardVel > 48.0f) {
src/game/mario_actions_moving.c:			m->forwardVel = 48.0f;
src/game/mario_actions_moving.c:        m->faceAngle[1] = m->intendedYaw;
src/game/mario_actions_moving.c:         m->faceAngle[1] = m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
src/game/mario_actions_moving.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_moving.c:        s32 slideLevel = (m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE;
src/game/mario_actions_moving.c:        s32 movingBackward = m->forwardVel <= -1.0f;
src/game/mario_actions_moving.c:    s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:        if (m->forwardVel >= 29.0f && m->controller->stickMag > 48.0f) {
src/game/mario_actions_moving.c:            m->vel[1] = 20.0f;
src/game/mario_actions_moving.c:    if (m->actionState == 1) {
src/game/mario_actions_moving.c:        m->faceAngle[1] = m->actionArg;
src/game/mario_actions_moving.c:    if (m->forwardVel >= 16.0f && m->floor->normal.y >= 0.17364818f) {
src/game/mario_actions_moving.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_moving.c:    val04 = m->intendedMag > m->forwardVel ? m->intendedMag : m->forwardVel;
src/game/mario_actions_moving.c:    if (m->quicksandDepth > 50.0f) {
src/game/mario_actions_moving.c:        m->actionTimer = 0;
src/game/mario_actions_moving.c:            switch (m->actionTimer) {
src/game/mario_actions_moving.c:                        m->actionTimer = 2;
src/game/mario_actions_moving.c:                            m->actionTimer = 2;
src/game/mario_actions_moving.c:                        m->actionTimer = 2;
src/game/mario_actions_moving.c:                        m->actionTimer = 1;
src/game/mario_actions_moving.c:                        m->actionTimer = 3;
src/game/mario_actions_moving.c:                        m->actionTimer = 2;
src/game/mario_actions_moving.c:    val04 = m->intendedMag > m->forwardVel ? m->intendedMag : m->forwardVel;
src/game/mario_actions_moving.c:        switch (m->actionTimer) {
src/game/mario_actions_moving.c:                    m->actionTimer = 1;
src/game/mario_actions_moving.c:                    m->actionTimer = 0;
src/game/mario_actions_moving.c:                    m->actionTimer = 2;
src/game/mario_actions_moving.c:                    m->actionTimer = 1;
src/game/mario_actions_moving.c:    s32 val04 = (s32)(m->intendedMag * 0x10000);
src/game/mario_actions_moving.c:    f32 dx = m->pos[0] - startPos[0];
src/game/mario_actions_moving.c:    f32 dz = m->pos[2] - startPos[2];
src/game/mario_actions_moving.c:    if (m->forwardVel > 6.0f) {
src/game/mario_actions_moving.c:    if (m->wall != NULL) {
src/game/mario_actions_moving.c:        wallAngle = atan2s(m->wall->normal.z, m->wall->normal.x);
src/game/mario_actions_moving.c:        dWallAngle = wallAngle - m->faceAngle[1];
src/game/mario_actions_moving.c:    if (m->wall == NULL || dWallAngle <= -0x71C8 || dWallAngle >= 0x71C8) {
src/game/mario_actions_moving.c:        m->flags |= MARIO_UNKNOWN_31;
src/game/mario_actions_moving.c:        if (m->marioObj->header.gfx.animInfo.animFrame < 20) {
src/game/mario_actions_moving.c:            play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:        m->actionState = 1;
src/game/mario_actions_moving.c:        m->actionArg = wallAngle + 0x8000;
src/game/mario_actions_moving.c:        m->marioObj->header.gfx.angle[1] = wallAngle + 0x8000;
src/game/mario_actions_moving.c:        m->marioObj->header.gfx.angle[2] = find_floor_slope(m, 0x4000);
src/game/mario_actions_moving.c:    struct MarioBodyState *val0C = m->marioBodyState;
src/game/mario_actions_moving.c:    UNUSED struct Object *marioObj = m->marioObj;
src/game/mario_actions_moving.c:    s16 animID = m->marioObj->header.gfx.animInfo.animID;
src/game/mario_actions_moving.c:        s16 dYaw = m->faceAngle[1] - startYaw;
src/game/mario_actions_moving.c:        s16 val02 = -(s16)(dYaw * m->forwardVel / 12.0f);
src/game/mario_actions_moving.c:        s16 val00 = (s16)(m->forwardVel * 170.0f);
src/game/mario_actions_moving.c:    struct MarioBodyState *val0C = m->marioBodyState;
src/game/mario_actions_moving.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_moving.c:    s16 dYaw = m->faceAngle[1] - startYaw;
src/game/mario_actions_moving.c:    s16 val04 = -(s16)(dYaw * m->forwardVel / 12.0f);
src/game/mario_actions_moving.c:    s16 val02 = (s16)(m->forwardVel * 170.0f);
src/game/mario_actions_moving.c:    s16 startYaw = m->faceAngle[1];
src/game/mario_actions_moving.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_moving.c:    if (m->framesSinceA < 2) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_moving.c:    if (analog_stick_held_back(m) && m->forwardVel >= 16.0f) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_moving.c:    m->actionState = 0;
src/game/mario_actions_moving.c:    vec3f_copy(startPos, m->pos);
src/game/mario_actions_moving.c:            if (m->intendedMag - m->forwardVel > 16.0f) {
src/game/mario_actions_moving.c:                m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:            m->actionTimer = 0;
src/game/mario_actions_moving.c:    if (m->actionState == 0 && (m->input & INPUT_A_DOWN)) {
src/game/mario_actions_moving.c:    m->actionState = 1;
src/game/mario_actions_moving.c:    if (m->forwardVel >= 0.0f) {
src/game/mario_actions_moving.c:        if ((m->forwardVel += 8.0f) >= 0.0f) {
src/game/mario_actions_moving.c:            m->forwardVel = 0.0f;
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    if (m->heldObj->behavior == segmented_to_virtual(bhvJumpingBox)) {
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_moving.c:    m->intendedMag *= 0.4f;
src/game/mario_actions_moving.c:            if (m->forwardVel > 16.0f) {
src/game/mario_actions_moving.c:    if (0.4f * m->intendedMag - m->forwardVel > 10.0f) {
src/game/mario_actions_moving.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_moving.c:    m->intendedMag *= 0.1f;
src/game/mario_actions_moving.c:            if (m->forwardVel > 10.0f) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_moving.c:    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    if (m->forwardVel >= 18.0f) {
src/game/mario_actions_moving.c:            if (m->forwardVel > 0.0f) {
src/game/mario_actions_moving.c:                begin_walking_action(m, -m->forwardVel, ACT_WALKING, 0);
src/game/mario_actions_moving.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_FIRST_PERSON)
src/game/mario_actions_moving.c:        && (m->input
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_FIRST_PERSON)) {
src/game/mario_actions_moving.c:        if (m->framesSinceA < 2) {
src/game/mario_actions_moving.c:        if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_moving.c:        if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_moving.c:        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:        if ((val0C = (s32)(m->forwardVel / 4.0f * 0x10000)) < 0x1000) {
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_moving.c:    m->intendedMag *= 0.4f;
src/game/mario_actions_moving.c:        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:        if ((val0C = (s32)(m->forwardVel * 0x10000)) < 0x1000) {
src/game/mario_actions_moving.c:    s16 startYaw = m->faceAngle[1];
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_moving.c:        if (m->forwardVel < 24.0f) {
src/game/mario_actions_moving.c:    set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_START_RIDING_SHELL : MARIO_ANIM_RIDING_SHELL);
src/game/mario_actions_moving.c:            play_sound(m->flags & MARIO_METAL_CAP ? SOUND_ACTION_METAL_BONK : SOUND_ACTION_BONK,
src/game/mario_actions_moving.c:                       m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_moving.c:    if (m->floor->type == SURFACE_BURNING) {
src/game/mario_actions_moving.c:        play_sound(SOUND_MOVING_RIDING_SHELL_LAVA, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:        play_sound(SOUND_MOVING_TERRAIN_RIDING_SHELL + m->terrainSoundAddend,
src/game/mario_actions_moving.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_Z_DOWN)) {
src/game/mario_actions_moving.c:    m->intendedMag *= 0.1f;
src/game/mario_actions_moving.c:            if (m->forwardVel > 10.0f) {
src/game/mario_actions_moving.c:    val04 = (s32)(m->intendedMag * 2.0f * 0x10000);
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    m->marioObj->oMarioBurnTimer += 2;
src/game/mario_actions_moving.c:    if (m->marioObj->oMarioBurnTimer > 160) {
src/game/mario_actions_moving.c:    if (m->waterLevel - m->floorHeight > 50.0f) {
src/game/mario_actions_moving.c:        play_sound(SOUND_GENERAL_FLAME_OUT, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    if (m->forwardVel < 8.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 8.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel > 48.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 48.0f;
src/game/mario_actions_moving.c:    m->forwardVel = approach_f32(m->forwardVel, 32.0f, 4.0f, 1.0f);
src/game/mario_actions_moving.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_moving.c:        m->faceAngle[1] =
src/game/mario_actions_moving.c:            m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x600, 0x600);
src/game/mario_actions_moving.c:    set_mario_anim_with_accel(m, MARIO_ANIM_RUNNING, (s32)(m->forwardVel / 2.0f * 0x10000));
src/game/mario_actions_moving.c:    m->particleFlags |= PARTICLE_FIRE;
src/game/mario_actions_moving.c:    play_sound(SOUND_MOVING_LAVA_BURN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    m->health -= 10;
src/game/mario_actions_moving.c:    if (m->health < 0x100) {
src/game/mario_actions_moving.c:    m->marioBodyState->eyeState = MARIO_EYES_DEAD;
src/game/mario_actions_moving.c:    s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_moving.c:    m->marioBodyState->torsoAngle[0] = (s32)(5461.3335f * m->intendedMag / 32.0f * coss(intendedDYaw));
src/game/mario_actions_moving.c:    m->marioBodyState->torsoAngle[2] = (s32)(-(5461.3335f * m->intendedMag / 32.0f * sins(intendedDYaw)));
src/game/mario_actions_moving.c:    vec3f_copy(pos, m->pos);
src/game/mario_actions_moving.c:    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:            if (m->forwardVel < -50.0f || 50.0f < m->forwardVel) {
src/game/mario_actions_moving.c:                play_sound(SOUND_MARIO_HOOHOO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:                m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_moving.c:                if (m->forwardVel > 16.0f) {
src/game/mario_actions_moving.c:                    m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_moving.c:            } else if (m->wall != NULL) {
src/game/mario_actions_moving.c:                s16 wallAngle = atan2s(m->wall->normal.z, m->wall->normal.x);
src/game/mario_actions_moving.c:                f32 slideSpeed = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
src/game/mario_actions_moving.c:                m->slideYaw = wallAngle - (s16)(m->slideYaw - wallAngle) + 0x8000;
src/game/mario_actions_moving.c:                m->vel[0] = m->slideVelX = slideSpeed * sins(m->slideYaw);
src/game/mario_actions_moving.c:                m->vel[2] = m->slideVelZ = slideSpeed * coss(m->slideYaw);
src/game/mario_actions_moving.c:	if (m->actionTimer == 5) {
src/game/mario_actions_moving.c:        if (m->framesSinceA<2) {
src/game/mario_actions_moving.c:		m->actionTimer++;
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_moving.c:    if (m->actionTimer < 30) {
src/game/mario_actions_moving.c:        m->actionTimer++;
src/game/mario_actions_moving.c:        if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:            if (m->forwardVel > 10.0f) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:        if (m->forwardVel >= 10.0f) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_moving.c:    if (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED)) {
src/game/mario_actions_moving.c:    if (is_anim_at_end(m) && m->forwardVel < 1.0f) {
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_moving.c:    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    if (m->actionTimer == 5) {
src/game/mario_actions_moving.c:        if (!(m->input & INPUT_ABOVE_SLIDE) && (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED))) {
src/game/mario_actions_moving.c:                m, m->forwardVel >= 0.0f ? ACT_FORWARD_ROLLOUT : ACT_BACKWARD_ROLLOUT, 0);
src/game/mario_actions_moving.c:        m->actionTimer++;
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_ABOVE_SLIDE) && (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED))) {
src/game/mario_actions_moving.c:        return set_mario_action(m, m->forwardVel > 0.0f ? ACT_FORWARD_ROLLOUT : ACT_BACKWARD_ROLLOUT,
src/game/mario_actions_moving.c:        m->marioBodyState->grabPos = GRAB_POS_LIGHT_OBJ;
src/game/mario_actions_moving.c:    if (m->forwardVel > 32.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 32.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel < -32.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = -32.0f;
src/game/mario_actions_moving.c:    } else if (m->forwardVel >= 0.0f) {
src/game/mario_actions_moving.c:        if (m->forwardVel >= 0.0f) {
src/game/mario_actions_moving.c:        if (m->health < 0x100) {
src/game/mario_actions_moving.c:                m->invincTimer = 30;
src/game/mario_actions_moving.c:        common_ground_knockback_action(m, MARIO_ANIM_FALL_OVER_BACKWARDS, 43, TRUE, m->actionArg);
src/game/mario_actions_moving.c:    if (animFrame == 43 && m->health < 0x100) {
src/game/mario_actions_moving.c:    if (animFrame == 54 && m->prevAction == ACT_SPECIAL_DEATH_EXIT) {
src/game/mario_actions_moving.c:        play_sound(SOUND_MARIO_MAMA_MIA, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:        common_ground_knockback_action(m, MARIO_ANIM_LAND_ON_STOMACH, 21, TRUE, m->actionArg);
src/game/mario_actions_moving.c:    if (animFrame == 23 && m->health < 0x100) {
src/game/mario_actions_moving.c:    common_ground_knockback_action(m, MARIO_ANIM_BACKWARD_KB, 22, TRUE, m->actionArg);
src/game/mario_actions_moving.c:    common_ground_knockback_action(m, MARIO_ANIM_FORWARD_KB, 20, TRUE, m->actionArg);
src/game/mario_actions_moving.c:    common_ground_knockback_action(m, MARIO_ANIM_SOFT_BACK_KB, 100, FALSE, m->actionArg);
src/game/mario_actions_moving.c:    common_ground_knockback_action(m, MARIO_ANIM_SOFT_FRONT_KB, 100, FALSE, m->actionArg);
src/game/mario_actions_moving.c:        common_ground_knockback_action(m, MARIO_ANIM_GROUND_BONK, 32, TRUE, m->actionArg);
src/game/mario_actions_moving.c:        play_sound(SOUND_MARIO_MAMA_MIA, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_moving.c:    } else if (m->forwardVel >= 16.0f) {
src/game/mario_actions_moving.c:        m->vel[1] = 0.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel > 16.0f) {
src/game/mario_actions_moving.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    if (m->floor->type >= SURFACE_SHALLOW_QUICKSAND && m->floor->type <= SURFACE_MOVING_QUICKSAND) {
src/game/mario_actions_moving.c:        m->quicksandDepth += (4 - m->actionTimer) * 3.5f - 0.5f;
src/game/mario_actions_moving.c:    if (m->floor->normal.y < 0.2923717f) {
src/game/mario_actions_moving.c:    m->doubleJumpTimer = landingAction->unk02;
src/game/mario_actions_moving.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_moving.c:    if (++m->actionTimer >= landingAction->numFrames) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_moving.c:        m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (m->forwardVel < 0.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 0.0f;
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_Z_DOWN)) {
src/game/mario_actions_moving.c:        m->input &= ~INPUT_A_PRESSED;
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_NONZERO_ANALOG)) {
src/game/mario_actions_moving.c:                          !m->marioObj->oMarioLongJumpIsSlow ? MARIO_ANIM_CROUCH_FROM_FAST_LONGJUMP
src/game/mario_actions_moving.c:    m->input &= ~INPUT_A_PRESSED;
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_NONZERO_ANALOG)) {
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_Z_DOWN)) {
src/game/mario_actions_moving.c:        m->input &= ~INPUT_A_PRESSED;
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_NONZERO_ANALOG)) {
src/game/mario_actions_moving.c:    if (m->actionTimer++ < 6) {
src/game/mario_actions_moving.c:        m->quicksandDepth -= (7 - m->actionTimer) * 0.8f;
src/game/mario_actions_moving.c:        if (m->quicksandDepth < 1.0f) {
src/game/mario_actions_moving.c:            m->quicksandDepth = 1.1f;
src/game/mario_actions_moving.c:        if (m->actionTimer >= 13) {
src/game/mario_actions_moving.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_moving.c:    if (!(m->action & ACT_FLAG_INVULNERABLE) && (m->input & INPUT_UNKNOWN_10)) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_SQUISHED) {
src/game/mario_actions_moving.c:    if (!(m->action & ACT_FLAG_INVULNERABLE)) {
src/game/mario_actions_moving.c:        if (m->health < 0x100) {
src/game/mario_actions_moving.c:    switch (m->action) {
src/game/mario_actions_moving.c:    if (!cancel && (m->input & INPUT_IN_WATER)) {
src/game/mario_actions_moving.c:        m->particleFlags |= PARTICLE_WAVE_TRAIL;
src/game/mario_actions_moving.c:        m->particleFlags &= ~PARTICLE_DUST;
src/game/mario_actions_object.c:    if (m->action & ACT_FLAG_MOVING) {
src/game/mario_actions_object.c:    switch (m->actionArg) {
src/game/mario_actions_object.c:            play_sound(SOUND_MARIO_PUNCH_YAH, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:                m->actionArg = 2;
src/game/mario_actions_object.c:                m->actionArg = 1;
src/game/mario_actions_object.c:            if (m->marioObj->header.gfx.animInfo.animFrame >= 2) {
src/game/mario_actions_object.c:                m->flags |= MARIO_PUNCHING;
src/game/mario_actions_object.c:            if (m->actionArg == 2) {
src/game/mario_actions_object.c:                m->marioBodyState->punchState = (0 << 6) | 4;
src/game/mario_actions_object.c:            if (m->marioObj->header.gfx.animInfo.animFrame <= 0) {
src/game/mario_actions_object.c:                m->flags |= MARIO_PUNCHING;
src/game/mario_actions_object.c:            if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_object.c:                m->actionArg = 3;
src/game/mario_actions_object.c:            play_sound(SOUND_MARIO_PUNCH_WAH, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:                m->actionArg = 5;
src/game/mario_actions_object.c:                m->actionArg = 4;
src/game/mario_actions_object.c:            if (m->marioObj->header.gfx.animInfo.animFrame > 0) {
src/game/mario_actions_object.c:                m->flags |= MARIO_PUNCHING;
src/game/mario_actions_object.c:            if (m->actionArg == 5) {
src/game/mario_actions_object.c:                m->marioBodyState->punchState = (1 << 6) | 4;
src/game/mario_actions_object.c:            if (m->marioObj->header.gfx.animInfo.animFrame <= 0) {
src/game/mario_actions_object.c:                m->flags |= MARIO_PUNCHING;
src/game/mario_actions_object.c:            if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_object.c:                m->actionArg = 6;
src/game/mario_actions_object.c:                m->marioBodyState->punchState = (2 << 6) | 6;
src/game/mario_actions_object.c:                m->flags |= MARIO_KICKING;
src/game/mario_actions_object.c:            animFrame = m->marioObj->header.gfx.animInfo.animFrame;
src/game/mario_actions_object.c:                m->flags |= MARIO_TRIPPING;
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_object.c:    if (m->actionState == 0 && (m->input & INPUT_A_DOWN)) {
src/game/mario_actions_object.c:    m->actionState = 1;
src/game/mario_actions_object.c:    if (m->actionArg == 0) {
src/game/mario_actions_object.c:        m->actionTimer = 7;
src/game/mario_actions_object.c:    mario_set_forward_vel(m, sPunchingForwardVelocities[m->actionTimer]);
src/game/mario_actions_object.c:    if (m->actionTimer > 0) {
src/game/mario_actions_object.c:        m->actionTimer--;
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (m->actionState == 0 && is_anim_at_end(m)) {
src/game/mario_actions_object.c:        m->actionState = 1;
src/game/mario_actions_object.c:    if (m->actionState == 1) {
src/game/mario_actions_object.c:        if (m->heldObj->oInteractionSubtype & INT_SUBTYPE_GRABS_MARIO) {
src/game/mario_actions_object.c:            m->marioBodyState->grabPos = GRAB_POS_HEAVY_OBJ;
src/game/mario_actions_object.c:            m->marioBodyState->grabPos = GRAB_POS_LIGHT_OBJ;
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (++m->actionTimer == 8) {
src/game/mario_actions_object.c:    if (m->heldObj && (m->heldObj->oInteractionSubtype & INT_SUBTYPE_HOLDABLE_NPC)) {
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (++m->actionTimer == 7) {
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (++m->actionTimer == 13) {
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_object.c:    if (m->actionState == 0) {
src/game/mario_actions_object.c:        m->actionState = 1;
src/game/mario_actions_object.c:        m->angleVel[1] = 0;
src/game/mario_actions_object.c:        m->marioBodyState->grabPos = GRAB_POS_BOWSER;
src/game/mario_actions_object.c:        play_sound(SOUND_MARIO_HRMM, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_object.c:        if (m->angleVel[1] <= -0xE00 || m->angleVel[1] >= 0xE00) {
src/game/mario_actions_object.c:            play_sound(SOUND_MARIO_SO_LONGA_BOWSER, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:            play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:        play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:    if (m->angleVel[1] == 0) {
src/game/mario_actions_object.c:        if (m->actionTimer++ > 120) {
src/game/mario_actions_object.c:        m->actionTimer = 0;
src/game/mario_actions_object.c:    if (m->intendedMag > 20.0f) {
src/game/mario_actions_object.c:        if (m->actionArg == 0) {
src/game/mario_actions_object.c:            m->actionArg = 1;
src/game/mario_actions_object.c:            m->twirlYaw = m->intendedYaw;
src/game/mario_actions_object.c:            spin = (s16)(m->intendedYaw - m->twirlYaw) / 0x80;
src/game/mario_actions_object.c:            m->twirlYaw = m->intendedYaw;
src/game/mario_actions_object.c:            m->angleVel[1] += spin;
src/game/mario_actions_object.c:            if (m->angleVel[1] > 0x1000) {
src/game/mario_actions_object.c:                m->angleVel[1] = 0x1000;
src/game/mario_actions_object.c:            if (m->angleVel[1] < -0x1000) {
src/game/mario_actions_object.c:                m->angleVel[1] = -0x1000;
src/game/mario_actions_object.c:        m->actionArg = 0;
src/game/mario_actions_object.c:        m->angleVel[1] = approach_s32(m->angleVel[1], 0, 64, 64);
src/game/mario_actions_object.c:    spin = m->faceAngle[1];
src/game/mario_actions_object.c:    m->faceAngle[1] += m->angleVel[1];
src/game/mario_actions_object.c:    if (m->angleVel[1] <= -0x100 && spin < m->faceAngle[1]) {
src/game/mario_actions_object.c:        play_sound(SOUND_OBJ_BOWSER_SPINNING, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:    if (m->angleVel[1] >= 0x100 && spin > m->faceAngle[1]) {
src/game/mario_actions_object.c:        play_sound(SOUND_OBJ_BOWSER_SPINNING, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:    if (m->angleVel[1] >= 0) {
src/game/mario_actions_object.c:        m->marioObj->header.gfx.angle[0] = -m->angleVel[1];
src/game/mario_actions_object.c:        m->marioObj->header.gfx.angle[0] = m->angleVel[1];
src/game/mario_actions_object.c:    if (++m->actionTimer == 1) {
src/game/mario_actions_object.c:        if (m->actionArg == 0) {
src/game/mario_actions_object.c:    m->angleVel[1] = 0;
src/game/mario_actions_object.c:    f32 waterSurface = m->waterLevel - 100;
src/game/mario_actions_object.c:    if (m->pos[1] < waterSurface) {
src/game/mario_actions_object.c:    if (m->input & INPUT_SQUISHED) {
src/game/mario_actions_object.c:    if (m->health < 0x100) {
src/game/mario_actions_object.c:    switch (m->action) {
src/game/mario_actions_object.c:    if (!cancel && (m->input & INPUT_IN_WATER)) {
src/game/mario_actions_object.c:        m->particleFlags |= PARTICLE_IDLE_WATER_WAVE;
src/game/mario_actions_stationary.c:    if (m->floor->normal.y < 0.29237169f) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_stationary.c:        m->faceAngle[1] = (s16) m->intendedYaw;
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_Z_DOWN) {
src/game/mario_actions_stationary.c:    if (m->floor->normal.y < 0.29237169f) {
src/game/mario_actions_stationary.c:    if (m->heldObj->oInteractionSubtype & INT_SUBTYPE_DROP_IMMEDIATELY) {
src/game/mario_actions_stationary.c:        m->heldObj->oInteractionSubtype =
src/game/mario_actions_stationary.c:            (s32)(m->heldObj->oInteractionSubtype & ~INT_SUBTYPE_DROP_IMMEDIATELY);
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_stationary.c:        m->faceAngle[1] = (s16) m->intendedYaw;
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_Z_DOWN) {
src/game/mario_actions_stationary.c:    if (m->quicksandDepth > 30.0f) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_IN_POISON_GAS) {
src/game/mario_actions_stationary.c:    if (!(m->actionArg & 1) && m->health < 0x300) {
src/game/mario_actions_stationary.c:    if (m->actionState == 3) {
src/game/mario_actions_stationary.c:        if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SNOW) {
src/game/mario_actions_stationary.c:    if (m->actionArg & 1) {
src/game/mario_actions_stationary.c:        switch (m->actionState) {
src/game/mario_actions_stationary.c:            if (++m->actionState == 3) {
src/game/mario_actions_stationary.c:                f32 deltaYOfFloorBehindMario = m->pos[1] - find_floor_height_relative_polar(m, -0x8000, 60.0f);
src/game/mario_actions_stationary.c:                if (deltaYOfFloorBehindMario < -24.0f || 24.0f < deltaYOfFloorBehindMario || m->floor->flags & SURFACE_FLAG_DYNAMIC) {
src/game/mario_actions_stationary.c:                    m->actionState = 0;
src/game/mario_actions_stationary.c:                    m->actionTimer++;
src/game/mario_actions_stationary.c:                    if (m->actionTimer < 10) {
src/game/mario_actions_stationary.c:                        m->actionState = 0;
src/game/mario_actions_stationary.c:    if (m->actionState == actionState && m->marioObj->header.gfx.animInfo.animFrame == animFrame) {
src/game/mario_actions_stationary.c:        play_sound(sound, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (m->quicksandDepth > 30.0f) {
src/game/mario_actions_stationary.c:    if (m->actionState == 4) {
src/game/mario_actions_stationary.c:    switch (m->actionState) {
src/game/mario_actions_stationary.c:            m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_stationary.c:            m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_stationary.c:    play_anim_sound(m, 3, 15, m->terrainSoundAddend + SOUND_ACTION_TERRAIN_BODY_HIT_GROUND);
src/game/mario_actions_stationary.c:        m->actionState++;
src/game/mario_actions_stationary.c:    if (m->actionState == 2 && animFrame == -1) {
src/game/mario_actions_stationary.c:        play_sound(SOUND_MARIO_YAWNING, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (m->actionState == 1 && animFrame == -1) {
src/game/mario_actions_stationary.c:        play_sound(SOUND_MARIO_IMA_TIRED, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (m->actionState == 2) {
src/game/mario_actions_stationary.c:    if (m->input
src/game/mario_actions_stationary.c:        return set_mario_action(m, ACT_WAKING_UP, m->actionState);
src/game/mario_actions_stationary.c:    if (m->quicksandDepth > 30.0f) {
src/game/mario_actions_stationary.c:        return set_mario_action(m, ACT_WAKING_UP, m->actionState);
src/game/mario_actions_stationary.c:    if (m->pos[1] - find_floor_height_relative_polar(m, -0x8000, 60.0f) > 24.0f) {
src/game/mario_actions_stationary.c:        return set_mario_action(m, ACT_WAKING_UP, m->actionState);
src/game/mario_actions_stationary.c:    m->marioBodyState->eyeState = MARIO_EYES_CLOSED;
src/game/mario_actions_stationary.c:    switch (m->actionState) {
src/game/mario_actions_stationary.c:            if (animFrame == -1 && !m->actionTimer) {
src/game/mario_actions_stationary.c:                play_sound(SOUND_MARIO_SNORING1, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:                play_sound(SOUND_MARIO_SNORING2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:                m->actionTimer++;
src/game/mario_actions_stationary.c:                if (m->actionTimer > 45) {
src/game/mario_actions_stationary.c:                    m->actionState++;
src/game/mario_actions_stationary.c:                m->actionState++;
src/game/mario_actions_stationary.c:                play_sound(SOUND_MARIO_SNORING2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:                play_sound(SOUND_MARIO_SNORING1, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (!m->actionTimer) {
src/game/mario_actions_stationary.c:        stop_sound(SOUND_MARIO_SNORING1, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:        stop_sound(SOUND_MARIO_SNORING2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:        stop_sound(SOUND_MARIO_SNORING3, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    m->actionTimer++;
src/game/mario_actions_stationary.c:    if (m->actionTimer > 20) {
src/game/mario_actions_stationary.c:    set_mario_animation(m, !m->actionArg ? MARIO_ANIM_WAKE_FROM_SLEEP : MARIO_ANIM_WAKE_FROM_LYING);
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input
src/game/mario_actions_stationary.c:        m->actionState = 2;
src/game/mario_actions_stationary.c:    switch (m->actionState) {
src/game/mario_actions_stationary.c:                m->particleFlags |= PARTICLE_BREATH;
src/game/mario_actions_stationary.c:                play_sound(SOUND_MARIO_PANTING_COLD, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:                play_sound(SOUND_ACTION_CLAP_HANDS_COLD, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:                m->actionState = 1;
src/game/mario_actions_stationary.c:                play_sound(SOUND_ACTION_CLAP_HANDS_COLD, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:        play_sound(SOUND_MARIO_COUGHING3, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:        play_sound(SOUND_MARIO_COUGHING2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:        play_sound(SOUND_MARIO_COUGHING1, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (segmented_to_virtual(&bhvJumpingBox) == m->heldObj->behavior) {
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_stationary.c:    if (m->quicksandDepth > 30.0f) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->quicksandDepth < 30.0f) {
src/game/mario_actions_stationary.c:    if (m->quicksandDepth > 70.0f) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_stationary.c:    if (!(m->input & INPUT_Z_DOWN)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->health >= 0x500) {
src/game/mario_actions_stationary.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->health >= 0x500) {
src/game/mario_actions_stationary.c:    m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (!(m->input & INPUT_FIRST_PERSON)
src/game/mario_actions_stationary.c:        && m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->marioObj->header.gfx.animInfo.animFrame == 6) {
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_HIT_BY_SHOCKWAVE) {
src/game/mario_actions_stationary.c:    if (m->actionTimer == 0) {
src/game/mario_actions_stationary.c:        if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK1) {
src/game/mario_actions_stationary.c:    if (++m->actionTimer == 48) {
src/game/mario_actions_stationary.c:    sp1E = (m->actionTimer % 16) << 12;
src/game/mario_actions_stationary.c:    sp18 = (f32)(((f32)(6 - m->actionTimer / 8) * 8.0f) + 4.0f);
src/game/mario_actions_stationary.c:    vec3f_set(m->vel, 0.0f, 0.0f, 0.0f);
src/game/mario_actions_stationary.c:        m->pos[1] = sins(sp1E) * sp18 + m->floorHeight;
src/game/mario_actions_stationary.c:        m->pos[1] = m->floorHeight - sins(sp1E) * sp18;
src/game/mario_actions_stationary.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_stationary.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_stationary.c:    if (m->framesSinceA < 2) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_stationary.c:    if (!(m->input & INPUT_Z_DOWN) || m->marioObj->header.gfx.animInfo.animFrame >= 6) {
src/game/mario_actions_stationary.c:        m->input &= ~INPUT_A_PRESSED;
src/game/mario_actions_stationary.c:    m->input &= ~(INPUT_FIRST_PERSON | INPUT_B_PRESSED);
src/game/mario_actions_stationary.c:    m->input &= ~INPUT_B_PRESSED;
src/game/mario_actions_stationary.c:    landing_step(m, !m->marioObj->oMarioLongJumpIsSlow ? MARIO_ANIM_CROUCH_FROM_FAST_LONGJUMP
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (++m->actionTimer == 4) {
src/game/mario_actions_stationary.c:    m->actionState = 1;
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->angleVel[1] > 0) {
src/game/mario_actions_stationary.c:        m->angleVel[1] -= 0x400;
src/game/mario_actions_stationary.c:        if (m->angleVel[1] < 0) {
src/game/mario_actions_stationary.c:            m->angleVel[1] = 0;
src/game/mario_actions_stationary.c:        m->twirlYaw += m->angleVel[1];
src/game/mario_actions_stationary.c:    m->marioObj->header.gfx.angle[1] += m->twirlYaw;
src/game/mario_actions_stationary.c:    if (is_anim_at_end(m) && m->angleVel[1] == 0) {
src/game/mario_actions_stationary.c:        m->faceAngle[1] += m->twirlYaw;
src/game/mario_actions_stationary.c:    m->actionState = 1;
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    s32 sp1C = (m->input & (INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE | INPUT_UNKNOWN_10)) != 0;
src/game/mario_actions_stationary.c:    if (m->actionState == 0) {
src/game/mario_actions_stationary.c:        set_camera_mode(m->area->camera, CAMERA_MODE_C_UP, 0x10);
src/game/mario_actions_stationary.c:        m->actionState = 1;
src/game/mario_actions_stationary.c:    } else if (!(m->input & INPUT_FIRST_PERSON) || sp1C) {
src/game/mario_actions_stationary.c:        set_camera_mode(m->area->camera, -1, 1);
src/game/mario_actions_stationary.c:    if (m->floor->type == SURFACE_LOOK_UP_WARP
src/game/mario_actions_stationary.c:        s16 sp1A = m->statusForCamera->headRotation[0];
src/game/mario_actions_stationary.c:        s16 sp18 = ((m->statusForCamera->headRotation[1] * 4) / 3) + m->faceAngle[1];
src/game/mario_actions_stationary.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_stationary.c:        if (m->action == ACT_SPAWN_SPIN_LANDING) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_SQUISHED) {
src/game/mario_actions_stationary.c:    if (m->action != ACT_UNKNOWN_0002020E) {
src/game/mario_actions_stationary.c:        if (m->health < 0x100) {
src/game/mario_actions_stationary.c:    switch (m->action) {
src/game/mario_actions_stationary.c:    if (!cancel && (m->input & INPUT_IN_WATER)) {
src/game/mario_actions_stationary.c:        m->particleFlags |= PARTICLE_IDLE_WATER_WAVE;
src/game/mario_actions_submerged.c:    s16 atSurface = m->pos[1] >= m->waterLevel - 130;
src/game/mario_actions_submerged.c:        m->particleFlags |= particleFlag;
src/game/mario_actions_submerged.c:            play_sound(SOUND_ACTION_UNKNOWN431, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    return (m->waterLevel - 80) - m->pos[1] < 400.0f;
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:        if (m->action & ACT_FLAG_INVULNERABLE) {
src/game/mario_actions_submerged.c:    } else if (!(m->action & ACT_FLAG_MOVING)) {
src/game/mario_actions_submerged.c:            vec3f_copy(m->pos, nextPos);
src/game/mario_actions_submerged.c:            m->floor = floor;
src/game/mario_actions_submerged.c:            m->floorHeight = floorHeight;
src/game/mario_actions_submerged.c:        vec3f_set(m->pos, nextPos[0], ceilHeight - 160.0f, nextPos[2]);
src/game/mario_actions_submerged.c:        m->floor = floor;
src/game/mario_actions_submerged.c:        m->floorHeight = floorHeight;
src/game/mario_actions_submerged.c:        vec3f_set(m->pos, nextPos[0], floorHeight, nextPos[2]);
src/game/mario_actions_submerged.c:        m->floor = floor;
src/game/mario_actions_submerged.c:        m->floorHeight = floorHeight;
src/game/mario_actions_submerged.c:    if (m->floor->type == SURFACE_FLOWING_WATER) {
src/game/mario_actions_submerged.c:        s16 currentAngle = m->floor->force << 8;
src/game/mario_actions_submerged.c:        f32 currentSpeed = sWaterCurrentSpeeds[m->floor->force >> 8];
src/game/mario_actions_submerged.c:            f32 dx = whirlpool->pos[0] - m->pos[0];
src/game/mario_actions_submerged.c:            f32 dy = whirlpool->pos[1] - m->pos[1];
src/game/mario_actions_submerged.c:            f32 dz = whirlpool->pos[2] - m->pos[2];
src/game/mario_actions_submerged.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_submerged.c:    vec3f_copy(step, m->vel);
src/game/mario_actions_submerged.c:    if (m->action & ACT_FLAG_SWIMMING) {
src/game/mario_actions_submerged.c:    nextPos[0] = m->pos[0] + step[0];
src/game/mario_actions_submerged.c:    nextPos[1] = m->pos[1] + step[1];
src/game/mario_actions_submerged.c:    nextPos[2] = m->pos[2] + step[2];
src/game/mario_actions_submerged.c:    if (nextPos[1] > m->waterLevel - 80) {
src/game/mario_actions_submerged.c:        nextPos[1] = m->waterLevel - 80;
src/game/mario_actions_submerged.c:        m->vel[1] = 0.0f;
src/game/mario_actions_submerged.c:    vec3f_copy(marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_submerged.c:    vec3s_set(marioObj->header.gfx.angle, -m->faceAngle[0], m->faceAngle[1], m->faceAngle[2]);
src/game/mario_actions_submerged.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_submerged.c:    m->angleVel[0] = 0;
src/game/mario_actions_submerged.c:    m->angleVel[1] = 0;
src/game/mario_actions_submerged.c:    m->forwardVel = approach_f32(m->forwardVel, 0.0f, 1.0f, 1.0f);
src/game/mario_actions_submerged.c:    m->vel[1] = approach_f32(m->vel[1], buoyancy, 2.0f, 1.0f);
src/game/mario_actions_submerged.c:    m->faceAngle[0] = approach_s32(m->faceAngle[0], 0, 0x200, 0x200);
src/game/mario_actions_submerged.c:    m->faceAngle[2] = approach_s32(m->faceAngle[2], 0, 0x100, 0x100);
src/game/mario_actions_submerged.c:    m->vel[0] = m->forwardVel * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->vel[2] = m->forwardVel * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    if (m->action & ACT_FLAG_STATIONARY) {
src/game/mario_actions_submerged.c:        m->forwardVel -= 2.0f;
src/game/mario_actions_submerged.c:    if (m->forwardVel < 0.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel = 0.0f;
src/game/mario_actions_submerged.c:    if (m->forwardVel > maxSpeed) {
src/game/mario_actions_submerged.c:        m->forwardVel = maxSpeed;
src/game/mario_actions_submerged.c:    if (m->forwardVel > decelThreshold) {
src/game/mario_actions_submerged.c:        m->forwardVel -= 0.5f;
src/game/mario_actions_submerged.c:    m->vel[0] = m->forwardVel * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->vel[1] = m->forwardVel * sins(m->faceAngle[0]) + buoyancy;
src/game/mario_actions_submerged.c:    m->vel[2] = m->forwardVel * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    s16 targetYawVel = -(s16)(10.0f * m->controller->stickX);
src/game/mario_actions_submerged.c:        if (m->angleVel[1] < 0) {
src/game/mario_actions_submerged.c:            m->angleVel[1] += 0x40;
src/game/mario_actions_submerged.c:            if (m->angleVel[1] > 0x10) {
src/game/mario_actions_submerged.c:                m->angleVel[1] = 0x10;
src/game/mario_actions_submerged.c:            m->angleVel[1] = approach_s32(m->angleVel[1], targetYawVel, 0x10, 0x20);
src/game/mario_actions_submerged.c:        if (m->angleVel[1] > 0) {
src/game/mario_actions_submerged.c:            m->angleVel[1] -= 0x40;
src/game/mario_actions_submerged.c:            if (m->angleVel[1] < -0x10) {
src/game/mario_actions_submerged.c:                m->angleVel[1] = -0x10;
src/game/mario_actions_submerged.c:            m->angleVel[1] = approach_s32(m->angleVel[1], targetYawVel, 0x20, 0x10);
src/game/mario_actions_submerged.c:        m->angleVel[1] = approach_s32(m->angleVel[1], 0, 0x40, 0x40);
src/game/mario_actions_submerged.c:    m->faceAngle[1] += m->angleVel[1];
src/game/mario_actions_submerged.c:    m->faceAngle[2] = -m->angleVel[1] * 8;
src/game/mario_actions_submerged.c:    s16 targetPitch = -(s16)(252.0f * m->controller->stickY);
src/game/mario_actions_submerged.c:    if (m->faceAngle[0] < 0) {
src/game/mario_actions_submerged.c:    if (m->faceAngle[0] < targetPitch) {
src/game/mario_actions_submerged.c:        if ((m->faceAngle[0] += pitchVel) > targetPitch) {
src/game/mario_actions_submerged.c:            m->faceAngle[0] = targetPitch;
src/game/mario_actions_submerged.c:    } else if (m->faceAngle[0] > targetPitch) {
src/game/mario_actions_submerged.c:        if ((m->faceAngle[0] -= pitchVel) < targetPitch) {
src/game/mario_actions_submerged.c:            m->faceAngle[0] = targetPitch;
src/game/mario_actions_submerged.c:    s16 *val = &m->marioBodyState->headAngle[0];
src/game/mario_actions_submerged.c:    if (m->faceAngle[0] > 0) {
src/game/mario_actions_submerged.c:        *val = approach_s32(*val, m->faceAngle[0] / 2, 0x80, 0x200);
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->faceAngle[0] < -0x1000) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:        m, m->actionArg == 0 ? MARIO_ANIM_WATER_ACTION_END_WITH_OBJ : MARIO_ANIM_STOP_GRAB_OBJ_WATER,
src/game/mario_actions_submerged.c:    D_80339FD4 = m->faceAngle[0] / 256.0f + 20.0f;
src/game/mario_actions_submerged.c:    if (D_80339FD2 != 0 && m->pos[1] > m->waterLevel - 85 && m->faceAngle[0] >= 0) {
src/game/mario_actions_submerged.c:            m->marioObj->header.gfx.pos[1] += D_80339FD4 * sins(D_80339FD0);
src/game/mario_actions_submerged.c:    UNUSED struct Object *marioObj = m->marioObj;
src/game/mario_actions_submerged.c:            if (m->faceAngle[0] < floorPitch) {
src/game/mario_actions_submerged.c:                m->faceAngle[0] = floorPitch;
src/game/mario_actions_submerged.c:            if (m->faceAngle[0] > -0x3000) {
src/game/mario_actions_submerged.c:                m->faceAngle[0] -= 0x100;
src/game/mario_actions_submerged.c:            if (m->controller->stickY == 0.0f) {
src/game/mario_actions_submerged.c:                if (m->faceAngle[0] > 0.0f) {
src/game/mario_actions_submerged.c:                    m->faceAngle[0] += 0x200;
src/game/mario_actions_submerged.c:                    if (m->faceAngle[0] > 0x3F00) {
src/game/mario_actions_submerged.c:                        m->faceAngle[0] = 0x3F00;
src/game/mario_actions_submerged.c:                    m->faceAngle[0] -= 0x200;
src/game/mario_actions_submerged.c:                    if (m->faceAngle[0] < -0x3F00) {
src/game/mario_actions_submerged.c:                        m->faceAngle[0] = -0x3F00;
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[0] = approach_s32(m->marioBodyState->headAngle[0], 0, 0x200, 0x200);
src/game/mario_actions_submerged.c:    s16 animFrame = m->marioObj->header.gfx.animInfo.animFrame;
src/game/mario_actions_submerged.c:    if (animFrame == 0 || animFrame == 12) play_sound(SOUND_ACTION_UNKNOWN434, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:    s32 probe = (s32)(m->pos[1] + 1.5f);
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:        if (probe >= m->waterLevel - 80 && m->faceAngle[0] >= 0 && m->controller->stickY < -60.0f) {
src/game/mario_actions_submerged.c:            vec3s_set(m->angleVel, 0, 0, 0);
src/game/mario_actions_submerged.c:            m->vel[1] = 62.0f;
src/game/mario_actions_submerged.c:            if (m->heldObj == NULL) {
src/game/mario_actions_submerged.c:    if (m->actionArg == 0) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (++m->actionTimer == 14) {
src/game/mario_actions_submerged.c:    if (m->actionTimer < 6) {
src/game/mario_actions_submerged.c:        m->forwardVel += 0.5f;
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 9) {
src/game/mario_actions_submerged.c:        m->forwardVel += 1.5f;
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 2) {
src/game/mario_actions_submerged.c:        if (m->actionTimer < 6 && (m->input & INPUT_A_PRESSED)) {
src/game/mario_actions_submerged.c:            m->actionState = 1;
src/game/mario_actions_submerged.c:        if (m->actionTimer == 9 && m->actionState == 1) {
src/game/mario_actions_submerged.c:            m->actionState = 0;
src/game/mario_actions_submerged.c:            m->actionTimer = 1;
src/game/mario_actions_submerged.c:    if (m->actionTimer == 1) {
src/game/mario_actions_submerged.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:    if (m->actionTimer < 6) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 15) {
src/game/mario_actions_submerged.c:    if ((m->input & INPUT_A_DOWN) && m->actionTimer >= 7) {
src/game/mario_actions_submerged.c:        if (m->actionTimer == 7 && sSwimStrength < 280) {
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 7) {
src/game/mario_actions_submerged.c:    m->actionTimer++;
src/game/mario_actions_submerged.c:    m->forwardVel -= 0.25f;
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (!(m->input & INPUT_A_DOWN)) {
src/game/mario_actions_submerged.c:        if (m->actionTimer == 0 && sSwimStrength < 280) {
src/game/mario_actions_submerged.c:    m->forwardVel = approach_f32(m->forwardVel, 12.0f, 0.1f, 0.15f);
src/game/mario_actions_submerged.c:    m->actionTimer = 1;
src/game/mario_actions_submerged.c:    if (m->forwardVel < 14.0f) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (++m->actionTimer == 17) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->actionTimer < 6) {
src/game/mario_actions_submerged.c:        m->forwardVel += 0.5f;
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 9) {
src/game/mario_actions_submerged.c:        m->forwardVel += 1.5f;
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 2) {
src/game/mario_actions_submerged.c:        if (m->actionTimer < 6 && (m->input & INPUT_A_PRESSED)) {
src/game/mario_actions_submerged.c:            m->actionState = 1;
src/game/mario_actions_submerged.c:        if (m->actionTimer == 9 && m->actionState == 1) {
src/game/mario_actions_submerged.c:            m->actionState = 0;
src/game/mario_actions_submerged.c:            m->actionTimer = 1;
src/game/mario_actions_submerged.c:    if (m->actionTimer == 1) {
src/game/mario_actions_submerged.c:        play_sound(SOUND_ACTION_SWIM, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 15) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if ((m->input & INPUT_A_DOWN) && m->actionTimer >= 7) {
src/game/mario_actions_submerged.c:    m->actionTimer++;
src/game/mario_actions_submerged.c:    m->forwardVel -= 0.25f;
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (!(m->input & INPUT_A_DOWN)) {
src/game/mario_actions_submerged.c:    m->forwardVel = approach_f32(m->forwardVel, 12.0f, 0.1f, 0.15f);
src/game/mario_actions_submerged.c:    if (m->forwardVel < 14.0f) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->actionTimer++ == 240) {
src/game/mario_actions_submerged.c:        m->heldObj->oInteractStatus = INT_STATUS_STOP_RIDING;
src/game/mario_actions_submerged.c:        m->heldObj = NULL;
src/game/mario_actions_submerged.c:    m->forwardVel = approach_f32(m->forwardVel, 30.0f, 2.0f, 1.0f);
src/game/mario_actions_submerged.c:    if (m->marioObj->collidedObjInteractTypes & INTERACT_GRABBABLE) {
src/game/mario_actions_submerged.c:        f32 dx = object->oPosX - m->pos[0];
src/game/mario_actions_submerged.c:        f32 dz = object->oPosZ - m->pos[2];
src/game/mario_actions_submerged.c:        s16 dAngleToObject = atan2s(dz, dx) - m->faceAngle[1];
src/game/mario_actions_submerged.c:            m->usedObj = object;
src/game/mario_actions_submerged.c:            m->marioBodyState->grabPos = GRAB_POS_LIGHT_OBJ;
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[0] = approach_s32(m->marioBodyState->headAngle[0], 0, 0x200, 0x200);
src/game/mario_actions_submerged.c:    if (m->actionTimer++ == 5) {
src/game/mario_actions_submerged.c:    if (m->forwardVel < 7.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel += 1.0f;
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[0] = approach_s32(m->marioBodyState->headAngle[0], 0, 0x200, 0x200);
src/game/mario_actions_submerged.c:    switch (m->actionState) {
src/game/mario_actions_submerged.c:                m->actionState = check_water_grab(m) + 1;
src/game/mario_actions_submerged.c:                if (m->heldObj->behavior == segmented_to_virtual(bhvKoopaShellUnderwater)) {
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[0] = 0;
src/game/mario_actions_submerged.c:            m->invincTimer = 30;
src/game/mario_actions_submerged.c:        set_mario_action(m, m->health >= 0x100 ? endAction : ACT_WATER_DEATH, 0);
src/game/mario_actions_submerged.c:    common_water_knockback_step(m, MARIO_ANIM_BACKWARDS_WATER_KB, ACT_WATER_IDLE, m->actionArg);
src/game/mario_actions_submerged.c:    common_water_knockback_step(m, MARIO_ANIM_WATER_FORWARD_KB, ACT_WATER_IDLE, m->actionArg);
src/game/mario_actions_submerged.c:    play_sound(SOUND_MOVING_SHOCKED, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:        m->actionTimer++;
src/game/mario_actions_submerged.c:        m->flags |= MARIO_METAL_SHOCK;
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 6) {
src/game/mario_actions_submerged.c:        m->invincTimer = 30;
src/game/mario_actions_submerged.c:        set_mario_action(m, m->health < 0x100 ? ACT_WATER_DEATH : ACT_WATER_IDLE, 0);
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[0] = 0;
src/game/mario_actions_submerged.c:    switch (m->actionState) {
src/game/mario_actions_submerged.c:            m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_submerged.c:                m->actionState = 1;
src/game/mario_actions_submerged.c:            m->marioBodyState->eyeState = MARIO_EYES_DEAD;
src/game/mario_actions_submerged.c:            if (m->marioObj->header.gfx.animInfo.animFrame == 30) {
src/game/mario_actions_submerged.c:    m->marioBodyState->eyeState = MARIO_EYES_DEAD;
src/game/mario_actions_submerged.c:    s32 stateFlags = m->heldObj != NULL;
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    } else if ((m->prevAction & ACT_FLAG_DIVING) || (m->input & INPUT_A_DOWN)) {
src/game/mario_actions_submerged.c:    m->actionTimer++;
src/game/mario_actions_submerged.c:    if (m->actionState == 0) {
src/game/mario_actions_submerged.c:        play_sound(SOUND_ACTION_UNKNOWN430, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:        if (m->peakHeight - m->pos[1] > 1150.0f) {
src/game/mario_actions_submerged.c:            play_sound(SOUND_MARIO_HAHA_2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:        m->particleFlags |= PARTICLE_WATER_SPLASH;
src/game/mario_actions_submerged.c:        m->actionState = 1;
src/game/mario_actions_submerged.c:        if (m->prevAction & ACT_FLAG_AIR) {
src/game/mario_actions_submerged.c:    if (stepResult == WATER_STEP_HIT_FLOOR || m->vel[1] >= endVSpeed || m->actionTimer > 20) {
src/game/mario_actions_submerged.c:    m->particleFlags |= PARTICLE_PLUNGE_BUBBLE;
src/game/mario_actions_submerged.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_submerged.c:    struct Object *whirlpool = m->usedObj;
src/game/mario_actions_submerged.c:    f32 dx = m->pos[0] - whirlpool->oPosX;
src/game/mario_actions_submerged.c:    f32 dz = m->pos[2] - whirlpool->oPosZ;
src/game/mario_actions_submerged.c:    if ((marioObj->oMarioWhirlpoolPosY += m->vel[1]) < 0.0f) {
src/game/mario_actions_submerged.c:        if (distance < 16.1f && m->actionTimer++ == 16) {
src/game/mario_actions_submerged.c:    m->vel[1] = -640.0f / (newDistance + 16.0f);
src/game/mario_actions_submerged.c:        dx = newDistance * sins(m->faceAngle[1]);
src/game/mario_actions_submerged.c:        dz = newDistance * coss(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->pos[0] = whirlpool->oPosX + dx * cosAngleChange + dz * sinAngleChange;
src/game/mario_actions_submerged.c:    m->pos[2] = whirlpool->oPosZ - dx * sinAngleChange + dz * cosAngleChange;
src/game/mario_actions_submerged.c:    m->pos[1] = whirlpool->oPosY + marioObj->oMarioWhirlpoolPosY;
src/game/mario_actions_submerged.c:    m->faceAngle[1] = atan2s(dz, dx) + 0x8000;
src/game/mario_actions_submerged.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_submerged.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_ACTION_SOUND_PLAYED)) {
src/game/mario_actions_submerged.c:        m->particleFlags |= PARTICLE_MIST_CIRCLE;
src/game/mario_actions_submerged.c:        play_sound(SOUND_ACTION_METAL_STEP_WATER, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_submerged.c:    f32 val = m->intendedMag / 1.5f;
src/game/mario_actions_submerged.c:    if (m->forwardVel <= 0.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel += 1.1f;
src/game/mario_actions_submerged.c:    } else if (m->forwardVel <= val) {
src/game/mario_actions_submerged.c:        m->forwardVel += 1.1f - m->forwardVel / 43.0f;
src/game/mario_actions_submerged.c:    } else if (m->floor->normal.y >= 0.95f) {
src/game/mario_actions_submerged.c:        m->forwardVel -= 1.0f;
src/game/mario_actions_submerged.c:    if (m->forwardVel > 32.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel = 32.0f;
src/game/mario_actions_submerged.c:    m->faceAngle[1] =
src/game/mario_actions_submerged.c:        m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
src/game/mario_actions_submerged.c:    m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->vel[0] = m->slideVelX;
src/game/mario_actions_submerged.c:    m->vel[1] = 0.0f;
src/game/mario_actions_submerged.c:    m->vel[2] = m->slideVelZ;
src/game/mario_actions_submerged.c:    UNUSED f32 nextY = m->pos[1] + m->vel[1];
src/game/mario_actions_submerged.c:    f32 waterSurface = m->waterLevel - 100;
src/game/mario_actions_submerged.c:    if (m->vel[1] > 0.0f && m->pos[1] > waterSurface) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:        s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_submerged.c:        m->forwardVel += 0.8f * coss(intendedDYaw);
src/game/mario_actions_submerged.c:        m->faceAngle[1] += 0x200 * sins(intendedDYaw);
src/game/mario_actions_submerged.c:        m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.25f, 0.25f);
src/game/mario_actions_submerged.c:    if (m->forwardVel > 16.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel -= 1.0f;
src/game/mario_actions_submerged.c:    if (m->forwardVel < 0.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel += 2.0f;
src/game/mario_actions_submerged.c:    m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    switch (m->actionState) {
src/game/mario_actions_submerged.c:    if (is_anim_at_end(m) && ++m->actionState == 3) {
src/game/mario_actions_submerged.c:        m->actionState = 0;
src/game/mario_actions_submerged.c:    if (m->pos[1] >= m->waterLevel - 150) {
src/game/mario_actions_submerged.c:        m->particleFlags |= PARTICLE_IDLE_WATER_WAVE;
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_submerged.c:    if ((val04 = (s32)(m->forwardVel / 4.0f * 0x10000)) < 0x1000) {
src/game/mario_actions_submerged.c:            m->forwardVel = 0.0f;
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_submerged.c:    m->intendedMag *= 0.4f;
src/game/mario_actions_submerged.c:    if ((val04 = (s32)(m->forwardVel / 2.0f * 0x10000)) < 0x1000) {
src/game/mario_actions_submerged.c:            m->forwardVel = 0.0f;
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:            m->forwardVel = 0.0f;
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:            m->forwardVel = 0.0f;
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:        m->faceAngle[1] += 0x400 * sins(m->intendedYaw - m->faceAngle[1]);
src/game/mario_actions_submerged.c:    set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_GENERAL_FALL : MARIO_ANIM_FALL_FROM_WATER);
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:        m->faceAngle[1] += 0x400 * sins(m->intendedYaw - m->faceAngle[1]);
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    if (m->pos[1] > m->waterLevel - 80) {
src/game/mario_actions_submerged.c:        if (m->waterLevel - 80 > m->floorHeight) {
src/game/mario_actions_submerged.c:            m->pos[1] = m->waterLevel - 80;
src/game/mario_actions_submerged.c:            if (m->action == ACT_WATER_SHELL_SWIMMING && m->heldObj != NULL) {
src/game/mario_actions_submerged.c:                m->heldObj->oInteractStatus = INT_STATUS_STOP_RIDING;
src/game/mario_actions_submerged.c:                m->heldObj = NULL;
src/game/mario_actions_submerged.c:    if (m->health < 0x100 && !(m->action & (ACT_FLAG_INTANGIBLE | ACT_FLAG_INVULNERABLE))) {
src/game/mario_actions_submerged.c:    m->quicksandDepth = 0.0f;
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[1] = 0;
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[2] = 0;
src/game/mario_actions_submerged.c:    switch (m->action) {
src/game/mario_step.c:    if (m->wall != NULL) {
src/game/mario_step.c:        s16 wallAngle = atan2s(m->wall->normal.z, m->wall->normal.x);
src/game/mario_step.c:        m->faceAngle[1] = wallAngle - (s16)(m->faceAngle[1] - wallAngle);
src/game/mario_step.c:        play_sound((m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_BONK : SOUND_ACTION_BONK,
src/game/mario_step.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_step.c:        play_sound(SOUND_ACTION_HIT, m->marioObj->header.gfx.cameraToObject);
src/game/mario_step.c:        mario_set_forward_vel(m, -m->forwardVel);
src/game/mario_step.c:        m->faceAngle[1] += 0x8000;
src/game/mario_step.c:    if (m->action & ACT_FLAG_RIDING_SHELL) {
src/game/mario_step.c:        m->quicksandDepth = 0.0f;
src/game/mario_step.c:        if (m->quicksandDepth < 1.1f) {
src/game/mario_step.c:            m->quicksandDepth = 1.1f;
src/game/mario_step.c:        switch (m->floor->type) {
src/game/mario_step.c:                if ((m->quicksandDepth += sinkingSpeed) >= 10.0f) {
src/game/mario_step.c:                    m->quicksandDepth = 10.0f;
src/game/mario_step.c:                if ((m->quicksandDepth += sinkingSpeed) >= 25.0f) {
src/game/mario_step.c:                    m->quicksandDepth = 25.0f;
src/game/mario_step.c:                if ((m->quicksandDepth += sinkingSpeed) >= 60.0f) {
src/game/mario_step.c:                    m->quicksandDepth = 60.0f;
src/game/mario_step.c:                if(m->pos[1]<m->floorHeight+5.0f){
src/game/mario_step.c:					if ((m->quicksandDepth += sinkingSpeed) >= 160.0f) {
src/game/mario_step.c:				if(m->pos[1]<m->floorHeight+5.0f){
src/game/mario_step.c:                m->quicksandDepth = 0.0f;
src/game/mario_step.c:    s16 floorDYaw = m->floorAngle - m->faceAngle[1];
src/game/mario_step.c:        m->forwardVel = 16.0f;
src/game/mario_step.c:        m->faceAngle[1] = m->floorAngle;
src/game/mario_step.c:        m->forwardVel = -16.0f;
src/game/mario_step.c:        m->faceAngle[1] = m->floorAngle + 0x8000;
src/game/mario_step.c:    struct Surface *floor = m->floor;
src/game/mario_step.c:        m->vel[0] += pushSpeed * sins(pushAngle);
src/game/mario_step.c:        m->vel[2] += pushSpeed * coss(pushAngle);
src/game/mario_step.c:    struct Surface *floor = m->floor;
src/game/mario_step.c:        if (m->action & ACT_FLAG_MOVING) {
src/game/mario_step.c:            s16 pushDYaw = m->faceAngle[1] - pushAngle;
src/game/mario_step.c:            pushSpeed = m->forwardVel > 0.0f ? -m->forwardVel * 0.5f : -8.0f;
src/game/mario_step.c:        m->vel[0] += pushSpeed * sins(pushAngle);
src/game/mario_step.c:        m->vel[2] += pushSpeed * coss(pushAngle);
src/game/mario_step.c:        play_sound(SOUND_ENV_WIND2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_step.c:    struct Object *marioObj = m->marioObj;
src/game/mario_step.c:    m->vel[1] = 0.0f;
src/game/mario_step.c:    m->pos[1] = m->floorHeight;
src/game/mario_step.c:    vec3f_copy(marioObj->header.gfx.pos, m->pos);
src/game/mario_step.c:    vec3s_set(marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_step.c:    struct Object *marioObj = m->marioObj;
src/game/mario_step.c:        m->pos[1] = m->floorHeight;
src/game/mario_step.c:        vec3f_copy(marioObj->header.gfx.pos, m->pos);
src/game/mario_step.c:        vec3s_set(marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_step.c:    m->wall = upperWall;
src/game/mario_step.c:    if ((m->action & ACT_FLAG_RIDING_SHELL) && floorHeight < waterLevel) {
src/game/mario_step.c:        vec3f_copy(m->pos, nextPos);
src/game/mario_step.c:        m->floor = floor;
src/game/mario_step.c:        m->floorHeight = floorHeight;
src/game/mario_step.c:    vec3f_set(m->pos, nextPos[0], floorHeight, nextPos[2]);
src/game/mario_step.c:    m->floor = floor;
src/game/mario_step.c:    m->floorHeight = floorHeight;
src/game/mario_step.c:        s16 wallDYaw = atan2s(upperWall->normal.z, upperWall->normal.x) - m->faceAngle[1];
src/game/mario_step.c:        intendedPos[0] = m->pos[0] + m->floor->normal.y * (m->vel[0] / 4.0f);
src/game/mario_step.c:        intendedPos[2] = m->pos[2] + m->floor->normal.y * (m->vel[2] / 4.0f);
src/game/mario_step.c:        intendedPos[1] = m->pos[1];
src/game/mario_step.c:    m->terrainSoundAddend = mario_get_terrain_sound_addend(m);
src/game/mario_step.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_step.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_step.c:    if (m->vel[1] > 0) {
src/game/mario_step.c:    if (displacementX * m->vel[0] + displacementZ * m->vel[2] > 0.0f) {
src/game/mario_step.c:    vec3f_copy(m->pos, ledgePos);
src/game/mario_step.c:    m->floor = ledgeFloor;
src/game/mario_step.c:    m->floorHeight = ledgePos[1];
src/game/mario_step.c:    m->floorAngle = atan2s(ledgeFloor->normal.z, ledgeFloor->normal.x);
src/game/mario_step.c:    m->faceAngle[0] = 0;
src/game/mario_step.c:    m->faceAngle[1] = atan2s(wall->normal.z, wall->normal.x) + 0x8000;
src/game/mario_step.c:    //m->wall = NULL;
src/game/mario_step.c:        if (nextPos[1] <= m->floorHeight) {
src/game/mario_step.c:            m->pos[1] = m->floorHeight;
src/game/mario_step.c:        m->pos[1] = nextPos[1];
src/game/mario_step.c:    if ((m->action & ACT_FLAG_RIDING_SHELL) && floorHeight < waterLevel) {
src/game/mario_step.c:            m->pos[0] = nextPos[0];
src/game/mario_step.c:            m->pos[2] = nextPos[2];
src/game/mario_step.c:            m->floor = floor;
src/game/mario_step.c:            m->floorHeight = floorHeight;
src/game/mario_step.c:        m->pos[1] = floorHeight;
src/game/mario_step.c:        if (m->vel[1] >= 0.0f) {
src/game/mario_step.c:            m->vel[1] = 0.0f;
src/game/mario_step.c:            if ((stepArg & AIR_STEP_CHECK_HANG) && m->ceil != NULL
src/game/mario_step.c:                && m->ceil->type == SURFACE_HANGABLE) {
src/game/mario_step.c:        if (nextPos[1] <= m->floorHeight) {
src/game/mario_step.c:            m->pos[1] = m->floorHeight;
src/game/mario_step.c:        m->pos[1] = nextPos[1];
src/game/mario_step.c:        vec3f_copy(m->pos, nextPos);
src/game/mario_step.c:        m->floor = floor;
src/game/mario_step.c:        m->floorHeight = floorHeight;
src/game/mario_step.c:    vec3f_copy(m->pos, nextPos);
src/game/mario_step.c:    m->floor = floor;
src/game/mario_step.c:    m->floorHeight = floorHeight;
src/game/mario_step.c:        m->wall = upperWall != NULL ? upperWall : lowerWall;
src/game/mario_step.c:        wallDYaw = atan2s(m->wall->normal.z, m->wall->normal.x) - m->faceAngle[1];
src/game/mario_step.c:        if (m->wall->type == SURFACE_BURNING) {
src/game/mario_step.c:            m->flags |= MARIO_UNKNOWN_30;
src/game/mario_step.c:    if (m->angleVel[1] > 1024) {
src/game/mario_step.c:        heaviness = 1024.0f / m->angleVel[1];
src/game/mario_step.c:    m->vel[1] -= 4.0f * heaviness;
src/game/mario_step.c:    if (m->vel[1] < terminalVelocity) {
src/game/mario_step.c:        m->vel[1] = terminalVelocity;
src/game/mario_step.c:    if (!(m->flags & MARIO_UNKNOWN_08)) {
src/game/mario_step.c:    if (m->action & (ACT_FLAG_INTANGIBLE | ACT_FLAG_INVULNERABLE)) {
src/game/mario_step.c:    if (!(m->input & INPUT_A_DOWN) && m->vel[1] > 20.0f) {
src/game/mario_step.c:        return (m->action & ACT_FLAG_CONTROL_JUMP_HEIGHT) != 0;
src/game/mario_step.c:    if (m->action == ACT_TWIRLING && m->vel[1] < 0.0f) {
src/game/mario_step.c:    } else if (m->action == ACT_SHOT_FROM_CANNON) {
src/game/mario_step.c:        m->vel[1] -= 1.0f;
src/game/mario_step.c:        if (m->vel[1] < -75.0f) {
src/game/mario_step.c:            m->vel[1] = -75.0f;
src/game/mario_step.c:    } else if (m->action == ACT_LONG_JUMP || m->action == ACT_SLIDE_KICK
src/game/mario_step.c:               || m->action == ACT_BBH_ENTER_SPIN) {
src/game/mario_step.c:        m->vel[1] -= 2.0f;
src/game/mario_step.c:        if (m->vel[1] < -75.0f) {
src/game/mario_step.c:            m->vel[1] = -75.0f;
src/game/mario_step.c:    } else if (m->action == ACT_LAVA_BOOST || m->action == ACT_FALL_AFTER_STAR_GRAB) {
src/game/mario_step.c:        m->vel[1] -= 3.2f;
src/game/mario_step.c:        if (m->vel[1] < -65.0f) {
src/game/mario_step.c:            m->vel[1] = -65.0f;
src/game/mario_step.c:    } else if (m->action == ACT_GETTING_BLOWN) {
src/game/mario_step.c:        m->vel[1] -= m->unkC4;
src/game/mario_step.c:        if (m->vel[1] < -75.0f) {
src/game/mario_step.c:            m->vel[1] = -75.0f;
src/game/mario_step.c:        m->vel[1] /= 4.0f;
src/game/mario_step.c:    } else if (m->action & ACT_FLAG_METAL_WATER) {
src/game/mario_step.c:        m->vel[1] -= 1.6f;
src/game/mario_step.c:        if (m->vel[1] < -16.0f) {
src/game/mario_step.c:            m->vel[1] = -16.0f;
src/game/mario_step.c:    } else if ((m->flags & MARIO_WING_CAP) && m->vel[1] < 0.0f && (m->input & INPUT_A_DOWN)) {
src/game/mario_step.c:        m->marioBodyState->wingFlutter = TRUE;
src/game/mario_step.c:        m->vel[1] -= 2.0f;
src/game/mario_step.c:        if (m->vel[1] < -37.5f) {
src/game/mario_step.c:            if ((m->vel[1] += 4.0f) > -37.5f) {
src/game/mario_step.c:                m->vel[1] = -37.5f;
src/game/mario_step.c:        m->vel[1] -= 4.0f;
src/game/mario_step.c:        if (m->vel[1] < -75.0f) {
src/game/mario_step.c:            m->vel[1] = -75.0f;
src/game/mario_step.c:    if (m->action != ACT_GROUND_POUND) {
src/game/mario_step.c:        offsetY = m->pos[1] - -1500.0f;
src/game/mario_step.c:        if (m->floor->type == SURFACE_VERTICAL_WIND && -3000.0f < offsetY && offsetY < 2000.0f) {
src/game/mario_step.c:            if (m->vel[1] < maxVelY) {
src/game/mario_step.c:                if ((m->vel[1] += maxVelY / 8.0f) > maxVelY) {
src/game/mario_step.c:                    m->vel[1] = maxVelY;
src/game/mario_step.c:            play_sound(SOUND_ENV_WIND2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_step.c:    m->wall = NULL;
src/game/mario_step.c:        intendedPos[0] = m->pos[0] + m->vel[0] / 4.0f;
src/game/mario_step.c:        intendedPos[1] = m->pos[1] + m->vel[1] / 4.0f;
src/game/mario_step.c:        intendedPos[2] = m->pos[2] + m->vel[2] / 4.0f;
src/game/mario_step.c:    if (m->vel[1] >= 0.0f) {
src/game/mario_step.c:        m->peakHeight = m->pos[1];
src/game/mario_step.c:    m->terrainSoundAddend = mario_get_terrain_sound_addend(m);
src/game/mario_step.c:     if (m->action != ACT_FLYING) {
src/game/mario_step.c:			if (m->Chaos_Vals[0]==6 | m->Chaos_Vals[1]==6){
src/game/mario_step.c:			}else if (m->Chaos_Vals[0]==7 | m->Chaos_Vals[1]==7){
src/game/mario_step.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_step.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_step.c:    m->vel[0] = m->forwardVel * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
src/game/mario_step.c:    m->vel[1] = m->forwardVel * sins(m->faceAngle[0]);
src/game/mario_step.c:    m->vel[2] = m->forwardVel * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
src/game/mario_step.c:    m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_step.c:    m->vel[1] = 0.0f;
src/game/mario_step.c:    m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/obj_behaviors_2.c: * However, most objects that use this function handle the far-from-home case
src/game/object_helpers.c:    s32 sp0 = o->header.gfx.animInfo.curAnim->loopEnd - 2;
src/game/object_helpers.c:    u32 animFlags = (s32) o->header.gfx.animInfo.curAnim->flags;
src/game/object_helpers.c:    s32 nearLoopEnd = o->header.gfx.animInfo.curAnim->loopEnd - 2;
src/game/object_helpers.c:    s32 lastFrame = o->header.gfx.animInfo.curAnim->loopEnd - 1;
src/game/object_helpers.c:    s32 loopEnd = o->header.gfx.animInfo.curAnim->loopEnd;
src/game/platform_displacement.c:    rotation[0] = platform->oAngleVelPitch;
src/game/platform_displacement.c:    rotation[1] = platform->oAngleVelYaw;
src/game/platform_displacement.c:    rotation[2] = platform->oAngleVelRoll;
src/game/platform_displacement.c:    x += platform->oVelX;
src/game/platform_displacement.c:    z += platform->oVelZ;
src/game/platform_displacement.c:        unused3 = platform->oFaceAngleYaw;
src/game/platform_displacement.c:        platformPosX = platform->oPosX;
src/game/platform_displacement.c:        platformPosY = platform->oPosY;
src/game/platform_displacement.c:        platformPosZ = platform->oPosZ;
src/game/platform_displacement.c:        rotation[0] = platform->oFaceAnglePitch - platform->oAngleVelPitch;
src/game/platform_displacement.c:        rotation[1] = platform->oFaceAngleYaw - platform->oAngleVelYaw;
src/game/platform_displacement.c:        rotation[2] = platform->oFaceAngleRoll - platform->oAngleVelRoll;
src/game/platform_displacement.c:        rotation[0] = platform->oFaceAnglePitch;
src/game/platform_displacement.c:        rotation[1] = platform->oFaceAngleYaw;
src/game/platform_displacement.c:        rotation[2] = platform->oFaceAngleRoll;
src/game/rendering_graph_node.c:    if (anim->flags & ANIM_FLAG_HOR_TRANS) {
src/game/rendering_graph_node.c:    } else if (anim->flags & ANIM_FLAG_VERT_TRANS) {
src/game/rendering_graph_node.c:    } else if (anim->flags & ANIM_FLAG_6) {
src/game/rendering_graph_node.c:    gCurAnimEnabled = (anim->flags & ANIM_FLAG_5) == 0;
src/game/rendering_graph_node.c:    gCurrAnimAttribute = segmented_to_virtual((void *) anim->index);
src/game/rendering_graph_node.c:    gCurAnimData = segmented_to_virtual((void *) anim->values);
src/game/rendering_graph_node.c:    if (anim->animYTransDivisor == 0) {
src/game/rendering_graph_node.c:        gCurAnimTranslationMultiplier = (f32) node->animYTrans / (f32) anim->animYTransDivisor;
src/game/rendering_graph_node.c:    halfFov = ((gCurGraphNodeCamFrustum->fov*1.33333f) / 2.0f + 1.0f) * 32768.0f / 180.0f + 0.5f;
src/game/text_save.inc.h:    strftime(buffer, 26, "%Y-%m-%d %H:%M:%S", tm_info);
src/goddard/draw_objects.c:    if (cam->unk30 != NULL) {
src/goddard/draw_objects.c:        set_cur_dynobj(cam->unk30);
src/goddard/draw_objects.c:        sp44.x += cam->lookAt.x;
src/goddard/draw_objects.c:        sp44.y += cam->lookAt.y;
src/goddard/draw_objects.c:        sp44.z += cam->lookAt.z;
src/goddard/draw_objects.c:        sp44.x = cam->lookAt.x;
src/goddard/draw_objects.c:        sp44.y = cam->lookAt.y;
src/goddard/draw_objects.c:        sp44.z = cam->lookAt.z;
src/goddard/draw_objects.c:        gd_printf("%f,%f,%f\n", cam->worldPos.x, cam->worldPos.y, cam->worldPos.z);
src/goddard/draw_objects.c:    if (ABS(cam->worldPos.x - sp44.x) + ABS(cam->worldPos.z - sp44.z) == 0.0f) {
src/goddard/draw_objects.c:    gd_dl_lookat(cam, cam->worldPos.x, cam->worldPos.y, cam->worldPos.z, sp44.x, sp44.y, sp44.z, cam->unkA4);
src/goddard/draw_objects.c:    //func_80196430(pos, &cam->unkE8);
src/goddard/draw_objects.c:    gd_rotate_and_translate_vec3f(pos, &cam->unkE8);
src/goddard/dynlist_proc.c:    while (num--) {
src/goddard/gd_math.c: * Matrix has form-  | -(cz+sxy)/h sh  (cx-syz)/h 0 |
src/goddard/gd_math.c: * Has form-
src/goddard/gd_math.c: * Matrix has form-
src/goddard/objects.c:    newCam->id = gGdCameraCount;
src/goddard/objects.c:        newCam->next = oldCameraHead;
src/goddard/objects.c:    newCam->flags = flags | 0x10;
src/goddard/objects.c:    newCam->unk30 = a1;
src/goddard/objects.c:    gd_set_identity_mat4(&newCam->unk64);
src/goddard/objects.c:    gd_set_identity_mat4(&newCam->unkA8);
src/goddard/objects.c:    newCam->unk180.x = 1.0f;
src/goddard/objects.c:    newCam->unk180.y = 0.1f;
src/goddard/objects.c:    newCam->unk180.z = 1.0f;
src/goddard/objects.c:    newCam->unk134.x = 4.0f;
src/goddard/objects.c:    newCam->unk134.y = 4.0f;
src/goddard/objects.c:    newCam->unk134.z = 4.0f;
src/goddard/objects.c:    newCam->unk178 = 0.0f;
src/goddard/objects.c:    newCam->unk17C = 0.25f;
src/goddard/objects.c:    newCam->zoomLevel = 0;
src/goddard/objects.c:    newCam->maxZoomLevel = -1;
src/goddard/objects.c:    newCam->unkA4 = 0.0f;
src/goddard/objects.c:    newCam->lookAt.x = newCam->lookAt.y = newCam->lookAt.z = 0.0f;
src/goddard/objects.c:    newCam->worldPos.x = newCam->worldPos.y = newCam->worldPos.z = 0.0f;
src/goddard/objects.c:    newAnim->unk24 = 1.0f;
src/goddard/objects.c:    newAnim->frame = 1.0f;
src/goddard/objects.c:    newAnim->controlFunc = NULL;
src/goddard/objects.c:    newAnim->state = 0;
src/goddard/objects.c:    if (!(cam->flags & 0x10)) {
src/goddard/objects.c:    if ((spEC = cam->unk30) != NULL) {
src/goddard/objects.c:        spC8.x = sp70[2][0] - cam->unk58;
src/goddard/objects.c:        spC8.z = sp70[2][2] - cam->unk60;
src/goddard/objects.c:        cam->unk58 += spC8.x * cam->unk180.y;
src/goddard/objects.c:        cam->unk60 += spC8.z * cam->unk180.y;
src/goddard/objects.c:        cam->unkA8[2][0] = cam->unk58;
src/goddard/objects.c:        cam->unkA8[2][1] = 0.0f;
src/goddard/objects.c:        cam->unkA8[2][2] = cam->unk60;
src/goddard/objects.c:        cam->unkA8[0][0] = cam->unkA8[2][2];
src/goddard/objects.c:        cam->unkA8[0][1] = 0.0f;
src/goddard/objects.c:        cam->unkA8[0][2] = -cam->unkA8[2][0];
src/goddard/objects.c:        cam->unkA8[1][0] = 0.0f;
src/goddard/objects.c:        cam->unkA8[1][1] = 1.0f;
src/goddard/objects.c:        cam->unkA8[1][2] = 0.0f;
src/goddard/objects.c:        gd_set_identity_mat4(&cam->unkA8);
src/goddard/objects.c:        gd_set_identity_mat4(&cam->unkA8);
src/goddard/objects.c:    sp2C = &cam->unk64;
src/goddard/objects.c:    if ((cam->flags & CAMERA_FLAG_CONTROLLABLE) != 0) {
src/goddard/objects.c:            cam->zoomLevel++;
src/goddard/objects.c:            if (cam->zoomLevel > cam->maxZoomLevel) {
src/goddard/objects.c:                cam->zoomLevel = 0;
src/goddard/objects.c:            switch (cam->zoomLevel) {
src/goddard/objects.c:            cam->unk128.y += cam->unk134.y;
src/goddard/objects.c:            cam->unk128.y -= cam->unk134.y;
src/goddard/objects.c:            cam->unk128.x += cam->unk134.x;
src/goddard/objects.c:            cam->unk128.x -= cam->unk134.x;
src/goddard/objects.c:        cam->unk128.x = gd_clamp_f32(cam->unk128.x, 80.0f);
src/goddard/objects.c:        cam->unk4C.x = cam->zoomPositions[cam->zoomLevel].x;
src/goddard/objects.c:        cam->unk4C.y = cam->zoomPositions[cam->zoomLevel].y;
src/goddard/objects.c:        cam->unk4C.z = cam->zoomPositions[cam->zoomLevel].z;
src/goddard/objects.c:        gd_rot_2d_vec(cam->unk128.x, &cam->unk4C.y, &cam->unk4C.z);
src/goddard/objects.c:        gd_rot_2d_vec(-cam->unk128.y, &cam->unk4C.x, &cam->unk4C.z);
src/goddard/objects.c:        cam->unk40.x += (cam->unk4C.x - cam->unk40.x) * cam->unk17C;
src/goddard/objects.c:        cam->unk40.y += (cam->unk4C.y - cam->unk40.y) * cam->unk17C;
src/goddard/objects.c:        cam->unk40.z += (cam->unk4C.z - cam->unk40.z) * cam->unk17C;
src/goddard/objects.c:    spD4.x = cam->unk40.x;
src/goddard/objects.c:    spD4.y = cam->unk40.y;
src/goddard/objects.c:    spD4.z = cam->unk40.z;
src/goddard/objects.c:    gd_mult_mat4f(sp2C, &cam->unkA8, &cam->unkA8);
src/goddard/objects.c:    gd_mat4f_mult_vec3f(&spD4, &cam->unkA8);
src/goddard/objects.c:    cam->worldPos.x = spD4.x;
src/goddard/objects.c:    cam->worldPos.y = spD4.y;
src/goddard/objects.c:    cam->worldPos.z = spD4.z;
src/goddard/objects.c:    cam->worldPos.x += spE0.x;
src/goddard/objects.c:    cam->worldPos.y += spE0.y;
src/goddard/objects.c:    cam->worldPos.z += spE0.z;
src/goddard/renderer.c:    gd_mat4f_lookat(&cam->unkE8, arg1, arg2, arg3, arg4, arg5, arg6, gd_sin_d(arg7), gd_cos_d(arg7),
src/goddard/renderer.c:    mat4_to_mtx(&cam->unkE8, &DL_CURRENT_MTX(sCurrentGdDl));
src/goddard/renderer.c:    lookat->l[0].l.dir[0] = LOOKAT_PACK(cam->unkE8[0][0]);
src/goddard/renderer.c:    lookat->l[0].l.dir[1] = LOOKAT_PACK(cam->unkE8[1][0]);
src/goddard/renderer.c:    lookat->l[0].l.dir[2] = LOOKAT_PACK(cam->unkE8[2][0]);
src/goddard/renderer.c:    lookat->l[1].l.dir[0] = LOOKAT_PACK(cam->unkE8[0][1]);
src/goddard/renderer.c:    lookat->l[1].l.dir[1] = LOOKAT_PACK(cam->unkE8[1][1]);
src/goddard/renderer.c:    lookat->l[1].l.dir[2] = LOOKAT_PACK(cam->unkE8[2][1]);
src/goddard/renderer.c:    sp40.z = cam->unkE8[0][2] + arg4->x;
src/goddard/renderer.c:    sp40.y = cam->unkE8[1][2] + arg4->y;
src/goddard/renderer.c:    sp40.x = cam->unkE8[2][2] + arg4->z;
src/goddard/renderer.c:            (((sp40.z * cam->unkE8[0][0]) + (sp40.y * cam->unkE8[1][0]) + (sp40.x * cam->unkE8[2][0]))
src/goddard/renderer.c:            (((sp40.z * cam->unkE8[0][1]) + (sp40.y * cam->unkE8[1][1]) + (sp40.x * cam->unkE8[2][1]))
src/goddard/renderer.c:    sVtxCvrtNormBuf[0] = (s8)(norm->x * 127.0f);
src/goddard/renderer.c:    sVtxCvrtNormBuf[1] = (s8)(norm->y * 127.0f);
src/goddard/renderer.c:    sVtxCvrtNormBuf[2] = (s8)(norm->z * 127.0f);
src/goddard/renderer.c:    sVtxCvrtNormBuf[0] = (s8)(norm->x * 127.0f);
src/goddard/renderer.c:    sVtxCvrtNormBuf[1] = (s8)(norm->y * 127.0f);
src/goddard/renderer.c:    sVtxCvrtNormBuf[2] = (s8)(norm->z * 127.0f);
src/pc/dlmalloc.c:  Win32 malloc: Random-looking failures from Win32 GDI API's (eg;
src/pc/dlmalloc.c:  If n is zero, malloc returns a minimum-sized chunk. (The minimum
src/pc/dlmalloc.c:  argument of zero (re)allocates a minimum-sized chunk.
src/pc/dlmalloc.c:  Equivalent to valloc(minimum-page-that-holds(n)), that is,
src/pc/dlmalloc.c:  large blocks of memory to potentially reduce the system-level memory
src/pc/dlmalloc.c:   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
src/pc/dlmalloc.c: mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
src/pc/dlmalloc.c:   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
src/pc/dlmalloc.c: mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
src/pc/dlmalloc.c:      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
src/pc/dlmalloc.c:      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
src/pc/dlmalloc.c:  msegmentptr sp = &m->seg;
src/pc/dlmalloc.c:  msegmentptr sp = &m->seg;
src/pc/dlmalloc.c:    gm->mflags = mparams.default_mflags;
src/pc/dlmalloc.c:    (void)INITIAL_LOCK(&gm->mutex);
src/pc/dlmalloc.c:  assert(sz == m->topsize);
src/pc/dlmalloc.c:  if (p != m->dv && p != m->top) {
src/pc/dlmalloc.c:      assert (next == m->top || is_inuse(next));
src/pc/dlmalloc.c:  int empty = (m->treemap & (1U << i)) == 0;
src/pc/dlmalloc.c:  unsigned int empty = (m->smallmap & (1U << i)) == 0;
src/pc/dlmalloc.c:    msegmentptr s = &m->seg;
src/pc/dlmalloc.c:    sum += m->topsize + TOP_FOOT_SIZE;
src/pc/dlmalloc.c:             q != m->top && q->head != FENCEPOST_HEAD) {
src/pc/dlmalloc.c:          assert(q == m->dv || bin_find(m, q));
src/pc/dlmalloc.c:  if (m->dvsize != 0) { /* check dv chunk */
src/pc/dlmalloc.c:    do_check_any_chunk(m, m->dv);
src/pc/dlmalloc.c:    assert(m->dvsize == chunksize(m->dv));
src/pc/dlmalloc.c:    assert(m->dvsize >= MIN_CHUNK_SIZE);
src/pc/dlmalloc.c:    assert(bin_find(m, m->dv) == 0);
src/pc/dlmalloc.c:  if (m->top != 0) {   /* check top chunk */
src/pc/dlmalloc.c:    do_check_top_chunk(m, m->top);
src/pc/dlmalloc.c:    /*assert(m->topsize == chunksize(m->top)); redundant */
src/pc/dlmalloc.c:    assert(m->topsize > 0);
src/pc/dlmalloc.c:    assert(bin_find(m, m->top) == 0);
src/pc/dlmalloc.c:  assert(total <= m->footprint);
src/pc/dlmalloc.c:  assert(m->footprint <= m->max_footprint);
src/pc/dlmalloc.c:      size_t mfree = m->topsize + TOP_FOOT_SIZE;
src/pc/dlmalloc.c:      msegmentptr s = &m->seg;
src/pc/dlmalloc.c:               q != m->top && q->head != FENCEPOST_HEAD) {
src/pc/dlmalloc.c:      nm.hblkhd   = m->footprint - sum;
src/pc/dlmalloc.c:      nm.usmblks  = m->max_footprint;
src/pc/dlmalloc.c:      nm.uordblks = m->footprint - mfree;
src/pc/dlmalloc.c:      nm.keepcost = m->topsize;
src/pc/dlmalloc.c:      msegmentptr s = &m->seg;
src/pc/dlmalloc.c:      maxfp = m->max_footprint;
src/pc/dlmalloc.c:      fp = m->footprint;
src/pc/dlmalloc.c:      used = fp - (m->topsize + TOP_FOOT_SIZE);
src/pc/dlmalloc.c:               q != m->top && q->head != FENCEPOST_HEAD) {
src/pc/dlmalloc.c:  if (m->footprint_limit != 0) {
src/pc/dlmalloc.c:    size_t fp = m->footprint + mmsize;
src/pc/dlmalloc.c:    if (fp <= m->footprint || fp > m->footprint_limit)
src/pc/dlmalloc.c:      if (m->least_addr == 0 || mm < m->least_addr)
src/pc/dlmalloc.c:        m->least_addr = mm;
src/pc/dlmalloc.c:      if ((m->footprint += mmsize) > m->max_footprint)
src/pc/dlmalloc.c:        m->max_footprint = m->footprint;
src/pc/dlmalloc.c:      if (cp < m->least_addr)
src/pc/dlmalloc.c:        m->least_addr = cp;
src/pc/dlmalloc.c:      if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)
src/pc/dlmalloc.c:        m->max_footprint = m->footprint;
src/pc/dlmalloc.c:  m->top = p;
src/pc/dlmalloc.c:  m->topsize = psize;
src/pc/dlmalloc.c:  m->trim_check = mparams.trim_threshold; /* reset on each update */
src/pc/dlmalloc.c:  m->smallmap = m->treemap = 0;
src/pc/dlmalloc.c:  m->dvsize = m->topsize = 0;
src/pc/dlmalloc.c:  m->seg.base = 0;
src/pc/dlmalloc.c:  m->seg.size = 0;
src/pc/dlmalloc.c:  m->seg.next = 0;
src/pc/dlmalloc.c:  m->top = m->dv = 0;
src/pc/dlmalloc.c:  if (oldfirst == m->top) {
src/pc/dlmalloc.c:    size_t tsize = m->topsize += qsize;
src/pc/dlmalloc.c:    m->top = q;
src/pc/dlmalloc.c:  else if (oldfirst == m->dv) {
src/pc/dlmalloc.c:    size_t dsize = m->dvsize += qsize;
src/pc/dlmalloc.c:    m->dv = q;
src/pc/dlmalloc.c:  char* old_top = (char*)m->top;
src/pc/dlmalloc.c:  *ss = m->seg; /* Push current record */
src/pc/dlmalloc.c:  m->seg.base = tbase;
src/pc/dlmalloc.c:  m->seg.size = tsize;
src/pc/dlmalloc.c:  m->seg.sflags = mmapped;
src/pc/dlmalloc.c:  m->seg.next = ss;
src/pc/dlmalloc.c:  check_top_chunk(m, m->top);
src/pc/dlmalloc.c:  if (use_mmap(m) && nb >= mparams.mmap_threshold && m->topsize != 0) {
src/pc/dlmalloc.c:  if (m->footprint_limit != 0) {
src/pc/dlmalloc.c:    size_t fp = m->footprint + asize;
src/pc/dlmalloc.c:    if (fp <= m->footprint || fp > m->footprint_limit)
src/pc/dlmalloc.c:    msegmentptr ss = (m->top == 0)? 0 : segment_holding(m, (char*)m->top);
src/pc/dlmalloc.c:        fp = m->footprint + ssize; /* recheck limits */
src/pc/dlmalloc.c:            (m->footprint_limit == 0 ||
src/pc/dlmalloc.c:             (fp > m->footprint && fp <= m->footprint_limit)) &&
src/pc/dlmalloc.c:      ssize = granularity_align(nb - m->topsize + SYS_ALLOC_PADDING);
src/pc/dlmalloc.c:    if ((m->footprint += tsize) > m->max_footprint)
src/pc/dlmalloc.c:      m->max_footprint = m->footprint;
src/pc/dlmalloc.c:      if (m->least_addr == 0 || tbase < m->least_addr)
src/pc/dlmalloc.c:        m->least_addr = tbase;
src/pc/dlmalloc.c:      m->seg.base = tbase;
src/pc/dlmalloc.c:      m->seg.size = tsize;
src/pc/dlmalloc.c:      m->seg.sflags = mmap_flag;
src/pc/dlmalloc.c:      m->magic = mparams.magic;
src/pc/dlmalloc.c:      m->release_checks = MAX_RELEASE_CHECK_RATE;
src/pc/dlmalloc.c:      msegmentptr sp = &m->seg;
src/pc/dlmalloc.c:          segment_holds(sp, m->top)) { /* append */
src/pc/dlmalloc.c:        init_top(m, m->top, m->topsize + tsize);
src/pc/dlmalloc.c:        if (tbase < m->least_addr)
src/pc/dlmalloc.c:          m->least_addr = tbase;
src/pc/dlmalloc.c:        sp = &m->seg;
src/pc/dlmalloc.c:    if (nb < m->topsize) { /* Allocate from new or extended top space */
src/pc/dlmalloc.c:      size_t rsize = m->topsize -= nb;
src/pc/dlmalloc.c:      mchunkptr p = m->top;
src/pc/dlmalloc.c:      mchunkptr r = m->top = chunk_plus_offset(p, nb);
src/pc/dlmalloc.c:      check_top_chunk(m, m->top);
src/pc/dlmalloc.c:  msegmentptr pred = &m->seg;
src/pc/dlmalloc.c:        if (p == m->dv) {
src/pc/dlmalloc.c:          m->dv = 0;
src/pc/dlmalloc.c:          m->dvsize = 0;
src/pc/dlmalloc.c:          m->footprint -= size;
src/pc/dlmalloc.c:  m->release_checks = (((size_t) nsegs > (size_t) MAX_RELEASE_CHECK_RATE)?
src/pc/dlmalloc.c:    if (m->topsize > pad) {
src/pc/dlmalloc.c:      size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -
src/pc/dlmalloc.c:      msegmentptr sp = segment_holding(m, (char*)m->top);
src/pc/dlmalloc.c:        m->footprint -= released;
src/pc/dlmalloc.c:        init_top(m, m->top, m->topsize - released);
src/pc/dlmalloc.c:        check_top_chunk(m, m->top);
src/pc/dlmalloc.c:    if (released == 0 && m->topsize > m->trim_check)
src/pc/dlmalloc.c:      m->trim_check = MAX_SIZE_T;
src/pc/dlmalloc.c:        m->footprint -= psize;
src/pc/dlmalloc.c:      if (p != m->dv) {
src/pc/dlmalloc.c:        m->dvsize = psize;
src/pc/dlmalloc.c:      if (next == m->top) {
src/pc/dlmalloc.c:        size_t tsize = m->topsize += psize;
src/pc/dlmalloc.c:        m->top = p;
src/pc/dlmalloc.c:        if (p == m->dv) {
src/pc/dlmalloc.c:          m->dv = 0;
src/pc/dlmalloc.c:          m->dvsize = 0;
src/pc/dlmalloc.c:      else if (next == m->dv) {
src/pc/dlmalloc.c:        size_t dsize = m->dvsize += psize;
src/pc/dlmalloc.c:        m->dv = p;
src/pc/dlmalloc.c:        if (p == m->dv) {
src/pc/dlmalloc.c:          m->dvsize = psize;
src/pc/dlmalloc.c:    binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;
src/pc/dlmalloc.c:  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {
src/pc/dlmalloc.c:  binmap_t leastbit = least_bit(m->treemap);
src/pc/dlmalloc.c:      smallbits = gm->smallmap >> idx;
src/pc/dlmalloc.c:      else if (nb > gm->dvsize) {
src/pc/dlmalloc.c:        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
src/pc/dlmalloc.c:      if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
src/pc/dlmalloc.c:    if (nb <= gm->dvsize) {
src/pc/dlmalloc.c:      size_t rsize = gm->dvsize - nb;
src/pc/dlmalloc.c:      mchunkptr p = gm->dv;
src/pc/dlmalloc.c:        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
src/pc/dlmalloc.c:        gm->dvsize = rsize;
src/pc/dlmalloc.c:        size_t dvs = gm->dvsize;
src/pc/dlmalloc.c:        gm->dvsize = 0;
src/pc/dlmalloc.c:        gm->dv = 0;
src/pc/dlmalloc.c:    else if (nb < gm->topsize) { /* Split top */
src/pc/dlmalloc.c:      size_t rsize = gm->topsize -= nb;
src/pc/dlmalloc.c:      mchunkptr p = gm->top;
src/pc/dlmalloc.c:      mchunkptr r = gm->top = chunk_plus_offset(p, nb);
src/pc/dlmalloc.c:      check_top_chunk(gm, gm->top);
src/pc/dlmalloc.c:              fm->footprint -= psize;
src/pc/dlmalloc.c:              if (p != fm->dv) {
src/pc/dlmalloc.c:                fm->dvsize = psize;
src/pc/dlmalloc.c:            if (next == fm->top) {
src/pc/dlmalloc.c:              size_t tsize = fm->topsize += psize;
src/pc/dlmalloc.c:              fm->top = p;
src/pc/dlmalloc.c:              if (p == fm->dv) {
src/pc/dlmalloc.c:                fm->dv = 0;
src/pc/dlmalloc.c:                fm->dvsize = 0;
src/pc/dlmalloc.c:            else if (next == fm->dv) {
src/pc/dlmalloc.c:              size_t dsize = fm->dvsize += psize;
src/pc/dlmalloc.c:              fm->dv = p;
src/pc/dlmalloc.c:              if (p == fm->dv) {
src/pc/dlmalloc.c:                fm->dvsize = psize;
src/pc/dlmalloc.c:            if (--fm->release_checks == 0)
src/pc/dlmalloc.c:    else if (next == m->top) {  /* extend into top */
src/pc/dlmalloc.c:      if (oldsize + m->topsize > nb) {
src/pc/dlmalloc.c:        size_t newsize = oldsize + m->topsize;
src/pc/dlmalloc.c:        m->top = newtop;
src/pc/dlmalloc.c:        m->topsize = newtopsize;
src/pc/dlmalloc.c:    else if (next == m->dv) { /* extend into dv */
src/pc/dlmalloc.c:      size_t dvs = m->dvsize;
src/pc/dlmalloc.c:          m->dvsize = dsize;
src/pc/dlmalloc.c:          m->dv = r;
src/pc/dlmalloc.c:          m->dvsize = 0;
src/pc/dlmalloc.c:          m->dv = 0;
src/pc/dlmalloc.c:    if (should_trim(m, m->topsize))
src/pc/dlmalloc.c:    mchunkptr top = m->top;
src/pc/dlmalloc.c:    for (s = &m->seg; s != 0; s = s->next) {
src/pc/dlmalloc.c:  return gm->footprint;
src/pc/dlmalloc.c:  return gm->max_footprint;
src/pc/dlmalloc.c:  size_t maf = gm->footprint_limit;
src/pc/dlmalloc.c:  return gm->footprint_limit = result;
src/pc/dlmalloc.c:  (void)INITIAL_LOCK(&m->mutex);
src/pc/dlmalloc.c:  m->seg.base = m->least_addr = tbase;
src/pc/dlmalloc.c:  m->seg.size = m->footprint = m->max_footprint = tsize;
src/pc/dlmalloc.c:  m->magic = mparams.magic;
src/pc/dlmalloc.c:  m->release_checks = MAX_RELEASE_CHECK_RATE;
src/pc/dlmalloc.c:  m->mflags = mparams.default_mflags;
src/pc/dlmalloc.c:  m->extp = 0;
src/pc/dlmalloc.c:  m->exts = 0;
src/pc/dlmalloc.c:  check_top_chunk(m, m->top);
src/pc/dlmalloc.c:      m->seg.sflags = USE_MMAP_BIT;
src/pc/dlmalloc.c:    m->seg.sflags = EXTERN_BIT;
src/pc/dlmalloc.c:              fm->footprint -= psize;
src/pc/dlmalloc.c:              if (p != fm->dv) {
src/pc/dlmalloc.c:                fm->dvsize = psize;
src/pc/dlmalloc.c:            if (next == fm->top) {
src/pc/dlmalloc.c:              size_t tsize = fm->topsize += psize;
src/pc/dlmalloc.c:              fm->top = p;
src/pc/dlmalloc.c:              if (p == fm->dv) {
src/pc/dlmalloc.c:                fm->dv = 0;
src/pc/dlmalloc.c:                fm->dvsize = 0;
src/pc/dlmalloc.c:            else if (next == fm->dv) {
src/pc/dlmalloc.c:              size_t dsize = fm->dvsize += psize;
src/pc/dlmalloc.c:              fm->dv = p;
src/pc/dlmalloc.c:              if (p == fm->dv) {
src/pc/dlmalloc.c:                fm->dvsize = psize;
src/pc/dlmalloc.c:            if (--fm->release_checks == 0)
src/pc/dlmalloc.c:      * Incorporate suggestions and platform-specific changes.
src/pc/gfx/gfx_direct3d11.cpp:        if (d3d.shader_program->used_textures[i]) {
src/pc/gfx/gfx_direct3d11.cpp:    uint32_t stride = d3d.shader_program->num_floats * sizeof(float);
src/pc/gfx/gfx_direct3d11.cpp:        d3d.context->IASetInputLayout(d3d.shader_program->input_layout.Get());
src/pc/gfx/gfx_direct3d11.cpp:        d3d.context->VSSetShader(d3d.shader_program->vertex_shader.Get(), 0, 0);
src/pc/gfx/gfx_direct3d11.cpp:        d3d.context->PSSetShader(d3d.shader_program->pixel_shader.Get(), 0, 0);
src/pc/gfx/gfx_direct3d11.cpp:        if (d3d.last_blend_state.Get() != d3d.shader_program->blend_state.Get()) {
src/pc/gfx/gfx_direct3d11.cpp:            d3d.last_blend_state = d3d.shader_program->blend_state.Get();
src/pc/gfx/gfx_direct3d11.cpp:            d3d.context->OMSetBlendState(d3d.shader_program->blend_state.Get(), 0, 0xFFFFFFFF);
src/pc/gfx/gfx_whb.cpp:    return uniform->offset;
src/pc/gfx/gfx_whb.cpp:            GX2SetPixelTexture(&texture.texture, current_shader_program->samplers_location[tile]);
src/pc/gfx/gfx_whb.cpp:            GX2SetPixelSampler(&texture.sampler, current_shader_program->samplers_location[tile]);
src/pc/gfx/gfx_whb.cpp:        GX2SetPixelTexture(&texture, current_shader_program->samplers_location[tile]);
src/pc/gfx/gfx_whb.cpp:        GX2SetPixelSampler(sampler, current_shader_program->samplers_location[tile]);
src/pc/gfx/gfx_whb.cpp:    GX2SetAttribBuffer(0, vbo_len, sizeof(float) * current_shader_program->num_floats, new_vbo);
src/pc/platform.c:/* this calls a platform-specific impl function after forming the error message */
src/pc/platform.h:/* Platform-specific functions and whatnot */
text/us/dialogs.h:#define SCRAM "scram--"
text/us/dialogs.h:to talk to them--they'll\n\
Binary file textures/segment2/segment2.05600.rgba16.png matches
Binary file textures/skyboxes/bbh.png matches
Binary file textures/skyboxes/bidw.png matches
Binary file textures/skyboxes/bits.png matches
Binary file textures/skyboxes/clouds.png matches
Binary file textures/skyboxes/water.png matches
tools/asm_processor/asm-processor.py:                raise Failure("Wrongly computed size for section {} (diff {}). This is an asm-processor bug!".format(sectype, prev_loc- loc))
tools/asm_processor/asm-processor.py:    o_file = tempfile.NamedTemporaryFile(prefix='asm-processor', suffix='.o', delete=False)
tools/asm_processor/asm-processor.py:    s_file = tempfile.NamedTemporaryFile(prefix='asm-processor', suffix='.s', delete=False)
tools/asm_processor/asm-processor.py:                        raise Failure("multiple occurrences of late_rodata hex magic. Change asm-processor to use something better than 0xE0123456!")
tools/asm_processor/asm-processor.py:    parser.add_argument('--asm-prelude', dest='asm_prelude', help="path to a file containing a prelude to the assembly file (with .set and .macro directives, e.g.)")
tools/asm_processor/build.py:asm_processor = ['python3', os.path.join(dir_path, "asm-processor.py")]
tools/asm_processor/build.py:subprocess.check_call(asm_processor + opt_flags + [in_file, '--post-process', out_file, '--assembler', assembler_sh, '--asm-prelude', prelude])
tools/assemble_sound.py:            "date must have format yyyy-mm-dd",
tools/audiofile/audiofile.cpp:	if (!msadpcm->initializeCoefficients())
tools/audiofile/audiofile.cpp:	*chunkFrames = msadpcm->m_framesPerPacket;
tools/audiofile/audiofile.cpp:	if (!msadpcm->initializeCoefficients())
tools/audiofile/audiofile.cpp:	*chunkFrames = msadpcm->m_framesPerPacket;
Binary file tools/ido5.3_compiler/usr/lib/as1 matches
Binary file tools/ido5.3_compiler/usr/lib/libc.so.1 matches
Binary file tools/ido5.3_compiler/usr/lib/ugen matches
Binary file tools/ido5.3_compiler/usr/lib/uld matches
Binary file tools/ido5.3_compiler/usr/lib/uopt matches
tools/ido5.3_recomp/recomp.cpp:            const char *name = STR(sym_strtab, u32be(sym->st_name));
tools/ido5.3_recomp/recomp.cpp:            uint32_t addr = u32be(sym->st_value);
tools/ido5.3_recomp/recomp.cpp:            if (u16be(sym->st_shndx) != text_section_index || name[0] == '.') {
tools/ido5.3_recomp/recomp.cpp:            //disasm_label_add(state, name, addr, u32be(sym->st_size), true);
tools/ido5.3_recomp/recomp.cpp:            const char *name = STR(sym_dynstr, u32be(sym->st_name));
tools/ido5.3_recomp/recomp.cpp:            uint32_t addr = u32be(sym->st_value);
tools/ido5.3_recomp/recomp.cpp:            uint8_t type = ELF32_ST_TYPE(sym->st_info);
tools/ido5.3_recomp/recomp.cpp:                procedure_table_len = 40 * u32be(sym->st_value);
tools/ido5.3_recomp/recomp.cpp:            if ((u16be(sym->st_shndx) == SHN_MIPS_TEXT && type == STT_FUNC) ||
tools/ido5.3_recomp/recomp.cpp:                 (type == STT_OBJECT && (u16be(sym->st_shndx) == SHN_MIPS_ACOMMON || u16be(sym->st_shndx) == SHN_MIPS_DATA)))
tools/ido5.3_recomp/recomp.cpp:                //disasm_label_add(state, name, addr, u32be(sym->st_size), true);
tools/ido5.3_recomp/recomp.cpp:                if (u16be(sym->st_shndx) == SHN_MIPS_ACOMMON) {
tools/ido5.3_recomp/recomp.cpp:                if (u16be(sym->st_shndx) == SHN_MIPS_TEXT && type == STT_FUNC) {
tools/ido5.3_recomp/recomp.cpp:                } else if (type == STT_OBJECT && (u16be(sym->st_shndx) == SHN_UNDEF || u16be(sym->st_shndx) == SHN_COMMON)) {
tools/ido5.3_recomp/recomp.cpp:                symName = STR(sym_strtab, u32be(sym->st_name));
tools/seq_decoder.py:    print(f"Usage: {sys.argv[0]} (--emit-asm-macros | input.m64)")
tools/seq_decoder.py:if sys.argv[1] == "--emit-asm-macros":
tools/seq_decoder.py:    print("# To regenerate it, run: ./tools/seq_decoder.py --emit-asm-macros >seq_macros.inc")
tools/stb/stb_image.h:// zlib-from-memory implementation for PNG reading
tools/stb/stb_image.h:      // force the image data from big-endian to platform-native.
